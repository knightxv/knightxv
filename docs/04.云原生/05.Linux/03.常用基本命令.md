---
title: 常用基本命令
date: 2023-01-18 21:54:26
permalink: /pages/f19842/
categories:
  - 云原生
  - Linux
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
## [#](#五、常用基本命令) 五、常用基本命令

Shell 可以看作是一个命令解释器，为我们提供了交互式的文本控制台界面。我们可以 通过终端控制台来输入命令，由 shell 进行解释并最终交给内核执行。 本章就将分类介绍 常用的基本 shell 命令。

## [#](#_1、帮助命令) 1、帮助命令

### [#](#_1、man获得帮助信息) 1、man 获得帮助信息

```sh
man [命令或配置文件] (功能描述:获得帮助信息)
```

| 信息        | 功能                   |
| ----------- | ---------------------- |
| NAME        | 命令的名称和单行描述   |
| SYNOPSIS    | 怎样使用命令           |
| DESCRIPTION | 命令功能的深入讨论     |
| EXAMPLES    | 怎样使用命令的例子     |
| SEE ALSO    | 相关主题(通常是手册页) |

查看 ls 命令的帮助信息

### [#](#_2、help-获得-shell-内置命令的帮助信息) 2、help 获得 shell 内置命令的帮助信息

一部分基础功能的系统命令是直接内嵌在 shell 中的，系统加载启动之后会随着 shell 一起加载，常驻系统内存中。这部分命令被称为“内置(built-in)命令”;相应的其它命令被称为“外部命令”。

```sh
help 命令(功能描述:获得 shell 内置命令的帮助信息)
```

查看 cd 命令的帮助信息

### [#](#_3、查看内置命令) 3、查看内置命令

```sh
# 查看内置命令
enable

# 禁用某个内置命令
enable -n cd

# 启用内置命令（默认是启动的）
enable cd
```

### [#](#_4、常用快捷键) 4、常用快捷键

| 常用快捷键    | 功能                                |
| ------------- | ----------------------------------- |
| ctrl + c      | 停止进程                            |
| ctrl+l        | 清屏，等同于 clear;彻底清屏是:reset |
| 善于用 tab 键 | 提示(更重要的是可以防止敲错)        |
| 上下键        | 查找执行过的命令                    |

## [#](#_2、文件目录类) 2、文件目录类

### [#](#_1、ls命令) 1、ls 命令

就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)和查看目录信息等等。

**常用参数搭配：**

**ls 命令主要用于浏览目录下的文件或者文件夹**

```sh
ls -a 列出目录所有文件，包含以.开始的隐藏文件
ls -A 列出除.及..的其它文件
ls -r 反序排列
ls -t 以文件修改时间排序
ls -S 以文件大小排序
ls -h 以易读大小显示
ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来,(常用)等价于“ll”
```

每行列出的信息依次是: **文件类型与权限 链接数 文件属主 文件属组 文件大小用 byte 来表示 建立或最近修改的时间 名字**

```sh
# 按易读方式按时间反序排序，并显示文件详细信息
ls -lhrt

# 按大小反序显示文件详细信息
ls -lrS

# 列出当前目录中所有以"t"开头的目录的详细内容
ls -l t*

# 列出文件绝对路径（不包含隐藏文件）
ls | sed "s:^:`pwd`/:"

# 列出文件绝对路径（包含隐藏文件）
find $pwd -maxdepth 1 | xargs ls -ld
```

### [#](#_2、cd-命令) 2、cd 命令

cd(changeDirectory) 命令语法：

**实例：**

```sh
# 切换至/home 目录
cd /home
cd ~
# 表示 切换至/root 目录
cd /root

# 切换至上一级目录
cd ../

# 表示以当前目录为参考，表示相对于当前
cd ./test

# 把上个命令的参数作为cd参数使用
cd !$

# 进入上一次工作路径
cd -

# 跳转到实际物理路径，而非快捷方式路径
cd -P
```

### [#](#_3、pwd-命令) 3、pwd 命令

pwd 命令用于查看当前工作目录路径。

**实例：**

```sh
#查看当前路径
pwd

#查看软链接的实际路径
pwd -P
```

### [#](#_4、mkdir-命令) 4、mkdir 命令

mkdir 命令用于创建文件夹。

可用选项：

-   **\-m**: 对新建目录设置存取权限，也可以用 chmod 命令设置;
-   **\-p**: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。

**实例：**

```sh
# 当前工作目录下创建名为 t的文件夹
mkdir t

# 在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建：
mkdir -p /tmp/test/t1/t
```

### [#](#_5、rm-命令) 5、rm 命令

删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。

```sh
rm [选项] 文件
-r: 递归删除目录中所有内容
-f: 强制删除。忽略不存在的文件，不提示确认
-i: 在删除前需要确认
-I: 在删除超过三个文件或者递归删除前要求去确认，此选项比-i提示内容更少，但同样可以阻止大多数错误发生;
```

**实例：**

```sh
# 删除任何 .log 文件，删除前逐一询问确认
rm -i *.log

# 删除 test 子目录及子目录中所有档案删除，并且不用一一确认
rm -rf test

# 删除以 -f 开头的文件
rm -- -f*
```

### [#](#_6、rmdir-命令) 6、rmdir 命令

从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。

**注意**：不能删除非空目录

**实例：**

```sh
# 当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除
rmdir -p parent/child/child11
```

### [#](#_7、mv-命令) 7、mv 命令

移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。

当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。

```sh
-b 类似--backup 但不接受参数
-f 覆盖前不询问
-i 覆盖前询问
-n 不覆盖已存在文件，如果您指定了-i、-f、-n 中的多个，仅最后一个生效;
```

**实例：**

```sh
# 将文件 test.log 重命名为 test1.txt
mv test.log test1.txt

# 将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中
mv log1.txt log2.txt log3.txt /test3

# 将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖
mv -i log1.txt log2.txt

# 移动当前文件夹下的所有文件到上一级目录
mv * ../
```

### [#](#_8、cp-命令) 8、cp 命令

将源文件复制至目标文件，或将多个源文件复制至目标目录。

注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！

```sh
-i 提示
-r 复制目录及目录内所有项目
-a 复制的文件与原文件时间一样
--path 指定在复制的时候自动创建不存在的子目录。
```

**实例：**

```sh
# 复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖
cp -ai a.txt test

# 为 a.txt 建立一个链接（快捷方式）
cp -s a.txt link_a.txt
```

```sh
cp --path java/com/server/Service.java target/
# 如果 target 目录下不存在 java/com/server/ 这一串子目录，cp --path 命令会自动创建 java/com/server/ 这一串子目录，然后把文件复制到对应的子目录下。

从行为来看，cp --path java/com/server/Service.java target/ 命令类似于下面的命令：
mkdir -p target/java/com/server/
cp java/com/server/Service.java target/java/com/server/
```

**经验技巧**

强制覆盖不提示的方法: \\cp

### [#](#_9、ln-命令) 9、ln 命令

功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。

链接分类：软件链接及硬链接

软链接：

-   1.软链接，以路径的形式存在。类似于 Windows 操作系统中的快捷方式
-   2.软链接可以 跨文件系统 ，硬链接不可以
-   3.软链接可以对一个不存在的文件名进行链接
-   4.软链接可以对目录进行链接

硬链接:

-   1.硬链接，以文件副本的形式存在。但不占用实际空间。
-   2.不允许给目录创建硬链接
-   3.硬链接只有在同一个文件系统中才能创建

**需要注意：**

-   第一：ln 命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；
-   第二：ln 的链接又分软链接和硬链接两种，软链接就是 ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。
-   第三：ln 指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。

**常用参数：**

```sh
-b 删除，覆盖以前建立的链接
-s 软链接（符号链接）
-v 显示详细处理过程
```

**经验技巧**

删除软链接: rm -rf 软链接名，而不是 rm -rf 软链接名/

如果使用 rm -rf 软链接名/ 删除，会把软链接对应的真实目录下内容删掉

查询:通过 ll 就可以查看，列表属性第 1 位是 l，尾部会有位置指向。

**实例：**

```sh
#给文件创建软链接，并显示操作信息
ln -sv source.log link.log

#给文件创建硬链接，并显示操作信息
ln -v source.log link1.log

#给目录创建软链接
ln -sv /opt/soft/test/test3 /opt/soft/test/test5
```

### [#](#_10、history-查看已经执行过历史命令) 10、history 查看已经执行过历史命令

## [#](#_3、文件内容相关) 3、文件内容相关

### [#](#_1、cat-命令) 1、cat 命令

cat 主要有三大功能：

1.一次显示整个文件:

2.创建一个文件:

只能创建新文件，不能编辑已有文件。

3.将几个文件合并为一个文件:

**实例：**

（1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里

```sh
cat -n log2012.log log2013.log
```

（2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里

```sh
cat -b log2012.log log2013.log log.log
```

（3）使用 here doc 生成新文件

```sh
cat >log.txt <<EOF
>Hello
>World
>PWD=$(pwd)
>EOF
ls -l log.txt
cat log.txt
Hello
World
PWD=/opt/soft/test
```

（4）反向列示

```sh
tac log.txt
PWD=/opt/soft/test
World
Hello
```

（5）检索关键词前后 N 行日志

```sh
cat nohup.out | grep "关键字" -C N
  C可以换成A或者B，当搜索到关键词后，关键词将在日志中高亮展示。说明：
-A 表示关键字之后，After
-B 表示关键字之前，Before
-C 表示关键字前后，Context
```

(6) 查看指定行日志

```sh
从第100行开始，显示50行：
cat nohup.out | tail -n +100| head -n 50
```

### [#](#_2、head-命令) 2、head 命令

head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。

**常用参数：**

```sh
-n<行数> 显示的行数（行数为复数表示从最后向前数）
```

**实例：**

```sh
# 显示 1.log 文件中前 20 行
head 1.log -n 20

# 显示 1.log 文件前 20 字节
head -c 20 log2014.log

# 显示 t.log最后 10 行
head -n -10 t.log
```

### [#](#_3、tail-命令) 3、tail 命令

用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。

**常用参数：**

```sh
-f 循环读取（常用于查看递增的日志文件）
-n<行数> 显示行数（从后向前）
```

```sh
# 循环读取逐渐增加的文件内容
ping 127.0.0.1 > ping.log &
# 后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。
tail -f ping.log
```

查看最近 N 条日志并实时打印日志

```shell
tail -Nf nohup.out
# N为要查看的、最近多少条日志，例如`tail -100f nohup.out`显示 nohup.out里尾部100行的内容，且不断刷新。-f 常用于查阅正在改变的日志文件。
```

查看文件最后 100 行日志并支持手动刷新日志

```sh
tail -n 100 nohup.out | more
```

### [#](#_4、more-命令) 4、more 命令

功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。

**命令参数：**

```sh
+n      从笫 n 行开始显示
-n       定义屏幕大小为n行
+/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示
-c       从顶部清屏，然后显示
-d       提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能
-l        忽略Ctrl+l（换页）字符
-p       通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似
-s       把连续的多个空行显示为一行
-u       把文件内容中的下画线去掉
```

**常用操作命令：**

```sh
Enter    向下 n 行，需要定义。默认为 1 行
Ctrl+F   向下滚动一屏
空格键  向下滚动一屏
Ctrl+B  返回上一屏
=       输出当前行的行号
:f     输出文件名和当前行的行号
V      调用vi编辑器
!命令   调用Shell，并执行命令
q       退出more
```

**实例：**

```sh
# 显示文件中从第3行起的内容
more +3 text.txt

# 在所列出文件目录详细信息，借助管道使每次显示 5 行
ls -l | more -5
# 按空格显示下 5 行
```

### [#](#_5、less-命令) 5、less 命令

less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。

**常用命令参数：**

```sh
-i  忽略搜索时的大小写
-N  显示每行的行号
-o  <文件名> 将less 输出的内容在指定文件中保存起来
-s  显示连续空行为一行
/字符串：向下搜索“字符串”的功能
?字符串：向上搜索“字符串”的功能
n：重复前一个搜索（与 / 或 ? 有关）
N：反向重复前一个搜索（与 / 或 ? 有关）
-x <数字> 将“tab”键显示为规定的数字空格
b  向后翻一页
d  向后翻半页
h  显示帮助界面
Q  退出less 命令
u  向前滚动半页
y  向前滚动一行
空格键 滚动一行
回车键 滚动一页
[pagedown]： 向下翻动一页
[pageup]：   向上翻动一页
```

**实例：**

```sh
# ps 查看进程信息并通过 less 分页显示
ps -aux | less -N

# 查看多个文件
less 1.log 2.log
# 可以使用 n 查看下一个，使用 p 查看前一个
```

### [#](#_6、wc-命令) 6、wc 命令

wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出

命令格式：

**命令参数：**

```sh
-c 统计字节数
-l 统计行数
-m 统计字符数
-w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串
```

**实例：**

```sh
# 查找文件的 行数 单词数 字节数 文件名
wc text.txt
# 结果
7     8     70     test.txt

# 统计输出结果的行数
cat test.txt | wc -l
```

### [#](#_7、grep-命令) 7、grep 命令

强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。

grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。

命令格式：

```sh
grep [option] pattern file|dir
```

常用参数：

```sh
-A n --after-context显示匹配字符后n行
-B n --before-context显示匹配字符前n行
-C n --context 显示匹配字符前后n行
-c --count 计算符合样式的列数
-i 忽略大小写
-l 只列出文件内容符合指定的样式的文件名称
-f 从文件中读取关键词
-n 显示匹配内容的所在文件中行数
-R 递归查找文件夹
-v 不包含
-w 用于字符串精确匹配
```

grep 的规则表达式:

```sh
^  #锚定行的开始 如：'^grep'匹配所有以grep开头的行。
$  #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。
.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。
*  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。
.*   #一起用代表任意字符。
[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。
[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。
\(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。
\<      #锚定单词的开始，如:'\<grep'匹配包含以grep开头的单词的行。
\>      #锚定单词的结束，如'grep\>'匹配包含以grep结尾的单词的行。
x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。
x\{m,\}  #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。
x\{m,n\}  #重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。
\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。
\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。
\b    #单词锁定符，如: '\bgrep\b'只匹配grep。
```

**实例：**

```sh
# 查找指定进程
ps -ef | grep svn

# 查找指定进程个数
ps -ef | grep svn -c

# 从文件中读取关键词
cat test1.txt | grep -f key.log

# 从文件夹中递归查找以grep开头的行，并只列出文件
grep -lR '^grep' /tmp

# 查找非x开关的行内容
grep '^[^x]' test.txt

# 显示包含 ed 或者 at 字符的内容行
grep -E 'ed|at' test.txt
```

### [#](#_8、touch) 8、touch

**touch 命令主要用于创建普通文件**

```sh
将每个文件的访问时间和修改时间改为当前时间;
不存在的文件将会被创建为空文件，除非使用-c 或-h 选项;
如果文件名为"-"则特殊处理，更改与标准输出相关的文件的访问时间;
```

### [#](#_9、echo) 9、echo

```sh
> 表示覆盖，原内容被覆盖
>> 表示 追加，原内容不变
echo ok >> test.txt,表示向 test.txt 文件追加 OK 字符，不覆盖原文件里的内容

\\ 输出\本身
\n 换行符
\t 制表符，也就是 Tab 键
```

### [#](#_10、tar) 10、tar

```sh
-c 建立新的压缩文件
-f 指定压缩文件
-r 添加文件到已经压缩文件包中
-u 添加改了和现有的文件到压缩包中
-x 从压缩包中抽取文件
-t 显示压缩文件中的内容
-z 支持gzip压缩
-j 支持bzip2压缩
-Z 支持compress解压文件
-v 显示操作过程
```

```sh
# 有关 gzip 及 bzip2 压缩
gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz
          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz

bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2
       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2
```

```sh
# 将文件全部打包成 tar 包
tar -cvf log.tar 1.log,2.log 或tar -cvf log.*

# 将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩
tar -zcvf /tmp/etc.tar.gz /etc

# 查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的）
tar -ztvf /tmp/etc.tar.gz

# 要压缩打包 /home, /etc ，但不要 /home/dmtsai
tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc
```

### [#](#_11、-输出重定向和-追加) 11、**\>** 输出重定向和 **\>>** 追加

```sh
ls-l >文件 (功能描述:列表的内容写入文件a.txt中(覆盖写))
ls-al >>文件 (功能描述:列表的内容追加到文件aa.txt的末尾)
cat 文件 1 > 文件 2 (功能描述:将文件 1 的内容覆盖到文件 2)
echo “内容” >> 文件
```

### [#](#_12、vi) 12、vi

```sh
# 进入编辑
# 任何一个字母之后才会进入编辑模式, 一般来说按 i 即可
i, I, o, O, a,A, r, R
# 退出编辑
ESC
# 保存、退出
:wq 保存并退出
:q 未修改文件
:q! 已修改文件(强制退出)
```

| yy         | 复制当前行,正常模式使用,5yy 表示拷贝当前行向下的 5 行                                           |
| ---------- | ----------------------------------------------------------------------------------------------- |
| p          | 粘贴,正常模式使用                                                                               |
| dd         | 删除当前行,5dd 表示删除当前行向下的 5 行                                                        |
| /          | /关键字(回车 查找,输入 n 就是查找下一个,命令行模式使用)                                         |
| :set nu    | :set nu(显示行号,命令行模式下使用)                                                              |
| :set nonu  | :set nonu(取消行号,命令行模式下使用)                                                            |
| G          | G(到达文件最末行,正常模式下使用)                                                                |
| gg         | gg(到达文件首行,正常模式下使用)                                                                 |
| u          | u(撤销,正常模式下使用)                                                                          |
| :%s        | 替换 :%s/6379/6380 把 6379 替换成 6380                                                          |
| 到达指定行 | 到达指定行 一：显示行号 :set nu , 二：输入 20 这个数 , 三: 输入 shift+g;(将光标移动到 第 20 行) |

## [#](#_4、文件查找相关) 4、文件查找相关

### [#](#_1、which-命令) 1、which 命令

在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：

```sh
which     查看可执行文件的位置。
whereis 查看文件的位置。
locate  配合数据库查看文件位置。
find        实际搜寻硬盘查询文件名称。
```

which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。

**常用参数：**

```text
-n 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
```

**实例：**

```sh
# 查看 ls 命令是否存在，执行哪个
which ls

# 查看 which
which which

# 查看 cd
which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令）
# 查看当前 PATH 配置：
echo $PATH
```

### [#](#_2、whereis-命令) 2、whereis 命令

whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man 说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而 find 则是遍历硬盘查找文件。

**常用参数：**

```sh
-b   定位可执行文件。
-m   定位帮助文件。
-s   定位源代码文件。
-u   搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。
```

**实例：**

```sh
# 查找 locate 程序相关文件
whereis locate

# 查找 locate 的源码文件
whereis -s locate

# 查找 lcoate 的帮助文件
whereis -m locate
```

### [#](#_3、locate-命令) 3、locate 命令

locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。

locate 指令利用事先建立的系统中所有文件名称及路径的 locate 数据库实现快速定位给 定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。

locate 与 find 命令相似，可以使用如 \*、? 等进行正则匹配查找

由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。

**常用参数：**

```sh
-l num（要显示的行数）
-f   将特定的档案系统排除在外，如将proc排除在外
-r   使用正则运算式做为寻找条件
```

**实例：**

```sh
# 查找和 pwd 相关的所有文件(文件名中包含 pwd）
locate pwd

# 搜索 etc 目录下所有以 sh 开头的文件
locate /etc/sh

# 查找 /var 目录下，以 reason 结尾的文件
locate -r '^/var.*reason$'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符）
```

### [#](#_4、find-命令) 4、find 命令

用于在文件树中查找文件，并作出相应的处理。

命令格式：

```sh
find pathname -options [-print -exec -ok ...]
```

命令参数：

```sh
pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。
-print： find命令将匹配的文件输出到标准输出。
-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' {  } \;，注意{   }和\；之间的空格。
-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
```

**命令选项：**

```text
-name 按照文件名查找文件
-perm 按文件权限查找文件
-user 按文件属主查找文件
-group  按照文件所属的组来查找文件。
-type  查找某一类型的文件，诸如：
   b - 块设备文件
   d - 目录
   c - 字符设备文件
   l - 符号链接文件
   p - 管道文件
   f - 普通文件

-size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小
-amin n   查找系统中最后N分钟访问的文件
-atime n  查找系统中最后n*24小时访问的文件
-cmin n   查找系统中最后N分钟被改变文件状态的文件
-ctime n  查找系统中最后n*24小时被改变文件状态的文件
-mmin n   查找系统中最后N分钟被改变文件数据的文件
-mtime n  查找系统中最后n*24小时被改变文件数据的文件
(用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 )
-maxdepth n 最大查找目录深度
-prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略
-newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项
```

**实例：**

```sh
# 查找 48 小时内修改过的文件
find -atime -2

# 在当前目录查找 以 .log 结尾的文件。 . 代表当前目录
find ./ -name '*.log'

#搜索桌面目录下，文件名包含 1 的文件
find -name "*1*"
#搜索桌面目录下，所有以 .txt 为扩展名的文件
find -name "*.txt"
#搜索桌面目录下，以数字 1 开头的文件
find -name "1*"
#根据名称查找/home 目录下的 hello.txt 文件
find /home -name hello.txt
#查找整个 linux 系统下大于 20m 的文件,终止检索 CTRL+C
find / -size +20M

# 查找 /opt 目录下 权限为 777 的文件
find /opt -perm 777

# 查找大于 1K 的文件
find -size +1000c

# 查找等于 1000 字符的文件
find -size 1000c
```

\-exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面 find 查找出来的文件名。

**实例：**

```sh
# 在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒）
find . -type f -mtime +10 -exec rm -f {} \;

# 当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除
find . -name '*.log' mtime +5 -ok -exec rm {} \;

# 当前目录下查找文件名以 passwd 开头，内容包含 "pkg" 字符的文件
find . -f -name 'passwd*' -exec grep "pkg" {} \;

# 用 exec 选项执行 cp 命令
find . -name '*.log' -exec cp {} test3 \;
```

\-xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。

**实例：**

```sh
# 查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型
find . -type f -print | xargs file

# 查找当前目录下所有以 js 结尾的并且其中包含 'editor' 字符的普通文件
find . -type f -name "*.js" -exec grep -lF 'ueditor' {} \;
find -type f -name '*.js' | xargs grep -lF 'editor'

# 利用 xargs 执行 mv 命令
find . -name "*.log" | xargs -i mv {} test4

# 用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行：
find . -name \*(转义） -type f -print | xargs grep -n 'hostnames'

# 查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件：
find . -name '[a-z]*[4-9].log' -print

# 在 test 目录查找不在 test4 子目录查找
find test -path 'test/test4' -prune -o -print

# 实例1：查找更改时间比文件 log2012.log新但比文件 log2017.log 旧的文件
find -newer log2012.log ! -newer log2017.log
```

**使用 depth 选项：**

depth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。

```sh
# 实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找
find / -name "CON.FILE" -depth -print
```

### [#](#_5、grep-过滤查找及-管道符) 5、grep 过滤查找及“|”管道符

管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理

```sh
grep 选项 查找内容 源文件

-n 显示匹配行及行号。
```

## [#](#_5、进程管理相关) 5、进程管理相关

### [#](#_1、ps-命令) 1、ps 命令

ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top

linux 上进程有 5 种状态:

1.  运行(正在运行或在运行队列中等待)
2.  中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)
3.  不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)
4.  僵死(进程已终止, 但进程描述符存在, 直到父进程调用 wait4()系统调用后释放)
5.  停止(进程收到 SIGSTOP, SIGSTP, SIGTIN, SIGTOU 信号后停止运行运行)

ps 工具标识进程的 5 种状态码:

```sh
D 不可中断 uninterruptible sleep (usually IO)
R 运行 runnable (on run queue)
S 中断 sleeping
T 停止 traced or stopped
Z 僵死 a defunct (”zombie”) process
```

**命令参数：**

```sh
-A 显示所有进程
a 显示所有进程
-a 显示同一终端下所有进程
x 列出当前用户的所有进程，包括没有终端的进程
u 面向用户友好的显示风格
-u 列出某个用户关联的所有进程
c 显示进程真实名称
e 显示环境变量
-e 列出所有进程
f 显示进程间的关系
-f 显示完整格式的进程列表
r 显示当前终端运行的进程
-aux 显示所有包含其它使用的进程
```

**功能说明**

```sh
ps aux 显示信息说明
    USER:该进程是由哪个用户产生的
    PID:进程的 ID 号
    %CPU:该进程占用 CPU 资源的百分比，占用越高，进程越耗费资源;
    %MEM:该进程占用物理内存的百分比，占用越高，进程越耗费资源;
    VSZ:该进程占用虚拟内存的大小，单位 KB;
    RSS:该进程占用实际物理内存的大小，单位 KB;
    TTY:该进程是在哪个终端中运行的。对于 CentOS 来说，tty1 是图形化终端， tty2-tty6 是本地的字符界面终端。pts/0-255 代表虚拟终端。
    STAT:进程状态。常见的状态有:R:运行状态、S:睡眠状态、T:暂停状态、Z:僵尸状态、s:包含子进程、l:多线程、+:前台显示
    START:该进程的启动时间
    TIME:该进程占用 CPU 的运算时间，注意不是系统时间
    COMMAND:产生此进程的命令名

ps -ef 显示信息说明
    UID:用户 ID
    PID:进程 ID
    PPID:父进程 ID
    C:CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算， 执行优先级会降低;数值越小，表明进程是 I/O 密集型运算，执行优先级会提高
    STIME:进程启动的时间
    TTY:完整的终端名称
    TIME:CPU 时间
    CMD:启动进程所用的命令和参数
```

**如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux; 如果想查看进程的父进程 ID 可以使用 ef;**

**实例**：

```sh
# 显示当前所有进程环境变量及进程间关系
ps -ef

# 显示当前所有进程
ps -A

# 与grep联用查找某进程
ps -aux | grep apache

# 找出与 cron 与 syslog 这两个服务有关的 PID 号码
ps aux | grep '(cron|syslog)'

# 查找进程打印出PID
ps -ef | grep java | grep tomcat | awk '{print $2}'

# 使用内存前10
ps aux | sort -k4nr | head -n 10

# 比如说sort -k 1 -k 2 test.txt，那么就会根据test.txt文件中的第一列和第二列进行排序。
-n：依照数值的大小排序；
-r：以相反的顺序来排序

# 使用CPU前10
ps aux | sort -k3nr | head -n 10

# 查看 内存和 应用名
ps -aux |sort -k4nr | head -n 10 |tr -s ' '|cut -d ' ' -f 4,11
```

### [#](#_2、top-命令) 2、top 命令

显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等

**常用参数：**

```sh
-d 秒数 指定 top 命令每隔几秒更新。默认是 3 秒在 top 命令的交互模式当中可以执行的命令:
-c 显示完整的进程命令
-s 保密模式
-p <进程号> 指定进程显示,通过指定监控进程 ID 来仅仅监控某个进程的状态。
-n <次数>循环显示次数
-i 使 top 不显示任何闲置或者僵死进程。
```

**操作**

```sh
P 以 CPU 使用率排序，默认就是此项
M 以内存的使用率排序
N 以PID排序
q 退出top
```

**实例**：

```text
top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35
Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie
Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st
Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers
Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached

PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java
```

前五行是当前系统情况整体的统计信息区。

**第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下：**

14:06:23 — 当前系统时间

up 70 days, 16:44 — 系统已经运行了 70 天 16 小时 44 分钟（在这期间系统没有重启过的吆！）

2 users — 当前有 2 个用户登录系统

load average: 1.15, 1.42, 1.44 — load average 后面的三个数分别是 1 分钟、5 分钟、15 分钟的负载情况。

load average 数据是每隔 5 秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑 CPU 的数量，结果高于 5 的时候就表明系统在超负荷运转了。

**第二行，Tasks — 任务（进程），具体信息说明如下：**

系统现在共有 206 个进程，其中处于运行中的有 1 个，205 个在休眠（sleep），stoped 状态的有 0 个，zombie 状态（僵尸）的有 0 个。

**第三行，cpu 状态信息，具体属性说明如下：**

```text
5.9%us — 用户空间占用CPU的百分比。
3.4% sy — 内核空间占用CPU的百分比。
0.0% ni — 改变过优先级的进程占用CPU的百分比
90.4% id — 空闲CPU百分比
0.0% wa — IO等待占用CPU的百分比
0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
0.2% si — 软中断（Software Interrupts）占用CPU的百分比
```

\*\*备注：\*\*在这里 CPU 的使用比率和 windows 概念不同，需要理解 linux 系统用户空间和内核空间的相关知识！

**第四行，内存状态，具体信息如下：**

```text
32949016k total — 物理内存总量（32GB）
14411180k used — 使用中的内存总量（14GB）
18537836k free — 空闲内存总量（18GB）
169884k buffers — 缓存的内存量 （169M）
```

**第五行，swap 交换分区信息，具体信息说明如下：**

```text
32764556k total — 交换区总量（32GB）
0k used — 使用的交换区总量（0K）
32764556k free — 空闲交换区总量（32GB）
3612636k cached — 缓冲的交换区总量（3.6GB）
```

**第六行，空行。**

**第七行以下：各进程（任务）的状态监控，项目列信息说明如下：**

```text
PID — 进程id
USER — 进程所有者
PR — 进程优先级
NI — nice值。负值表示高优先级，正值表示低优先级
VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
SHR — 共享内存大小，单位kb
S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
%CPU — 上次更新到现在的CPU时间占用百分比
%MEM — 进程使用的物理内存百分比
TIME+ — 进程使用的CPU时间总计，单位1/100秒
COMMAND — 进程名称（命令名/命令行）
```

**top 交互命令**

```sh
h 显示top交互命令帮助信息
c 切换显示命令名称和完整命令行
m 以内存使用率排序
P 根据CPU使用百分比大小进行排序
T 根据时间/累计时间进行排序
W 将当前设置写入~/.toprc文件中
o或者O 改变显示项目的顺序
```

**查找 CPU 高的进程**

```sh
top
top -Hp pid
printf '%x' 线程id
jstack 线程id > x.txt
vi x.txt 搜索printf '%x' 线程id 生成的结果
```

### [#](#_3、kill-命令) 3、kill 命令

发送指定的信号到相应进程。不指定型号将发送 SIGTERM（15）终止指定进程。如果任无法终止该程序可用"-KILL" 参数，其发送的信号为 SIGKILL(9) ，将强制结束进程，使用 ps 命令或者 jobs 命令可以查看进程号。root 用户将影响用户的进程，非 root 用户只能影响自己的进程。

**常用参数：**

```sh
-9  表示强迫进程立即停止
-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称
-a  当处理当前进程时，不限制命令名和进程号的对应关系
-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号
-s  指定发送信号
-u  指定用户
```

**实例：**

```sh
# 通过进程名称杀死进程
killall firefox

# 先使用ps查找进程pro1，然后用kill杀掉
kill -9 $(ps -ef | grep pro1)

# xargs 捕获一个命令的输出，然后传递给另外一个命令  一般是和管道一起使用
ps -ef | grep java | grep tomcat | awk '{print $2}' | xargs kill -9
```

### [#](#_4、free-命令) 4、free 命令

显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。

**命令参数：**

```sh
-b 以Byte显示内存使用情况
-k 以kb为单位显示内存使用情况
-m 以mb为单位显示内存使用情况
-g 以gb为单位显示内存使用情况
-s<间隔秒数> 持续显示内存
-t 显示内存使用总合
```

**实例：**

```sh
# 显示内存使用情况
free
free -k
free -m

# 以总和的形式显示内存的使用信息
free -t

# 周期性查询内存使用情况
free -s 10


total:总内存大小
used:已使用内存的大小，包含了共享内存
free:未使用的内存大小
shared:共享内存的大小
buff/cache:缓存和缓冲区的大小
available:新进程可用内存的大小
available不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用的内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。
```

### [#](#_5、netstat) 5、netstat

```sh
netstat -anp | grep 进程号 查看该进程网络信息
netstat –nlp | grep 端口号 查看网络端口号占用情况

-a 显示所有正在监听(listen)和未监听的套接字(socket)
-n 拒绝显示别名，能显示数字的全部转化成数字
-l 仅列出在监听的服务状态
-p 表示显示哪个进程在调用

# 查看所有端口占用情况
netstat -nlpt
netstat -nlpt | grep 80

# 通过进程号查看sshd进程的网络信息
netstat -anp | grep sshd
```

### [#](#_6、pstree-查看进程树) 6、pstree 查看进程树

```sh
pstree [选项]

-p 显示进程的 PID
-u 显示进程的所属用户
```

```sh
# 显示进程 pid
pstree -p

# 显示进程所属用户
pstree -u
```

## [#](#_6、权限相关) 6、权限相关

### [#](#_1、文件属性) 1、文件属性

Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。 为了保护系统的安全性，Linux 系统对不同的用户访问同一文件(包括目录文件)的权限做 了不同的规定。在 Linux 中我们可以使用 ll 或者 ls -l 命令来显示一个文件的属性以及文件所属 的用户和组。

从左到右的 **10** 个字符表示

![image-20220408155809816](https://xiaoxue-blog.oss-cn-shenzhen.aliyuncs.com/blog/202207071735925.png?x-oss-process=style/style_one)

如果没有权限，就会出现减号\[ - \]而已。从左至右用 0-9 这些数字来表示:

```sh
0 首位表示类型
在Linux中第一个字符代表这个文件是目录、文件或链接文件等等
    - 代表文件
    d 代表目录
    l 链接文档(link file);
第1-3位确定属主(该文件的所有者)拥有该文件的权限。---User
第4-6位确定属组(所有者的同组用户)拥有该文件的权限，---Group
第7-9位确定其他用户拥有该文件的权限 ---Other
```

#### [#](#_1、rwx-作用文件和目录的不同解释) 1、rwx 作用文件和目录的不同解释

**作用到文件:** \[ r \]代表可读(read): 可以读取，查看

\[ w \]代表可写(write): 可以修改，但是不代表可以删除该文件，删除一个文件的前

提条件是对该文件所在的目录有写权限，才能删除该文件.

\[ x \]代表可执行(execute):可以被系统执行

**作用到目录:**

\[ r \]代表可读(read): 可以读取，ls 查看目录内容

\[ w \]代表可写(write): 可以修改，目录内创建+删除+重命名目录

\[ x \]代表可执行(execute):可以进入该目录

![image-20220408161731259](https://xiaoxue-blog.oss-cn-shenzhen.aliyuncs.com/blog/202207071736979.png?x-oss-process=style/style_one)

如果查看到是文件:链接数指的是硬链接个数。

如果查看的是文件夹:链接数指的是子文件夹个数。

### [#](#_2、chmod-命令) 2、chmod 命令

![image-20220408161804187](https://xiaoxue-blog.oss-cn-shenzhen.aliyuncs.com/blog/202207071736628.png?x-oss-process=style/style_one)

用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。

每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。

以文件 log2012.log 为例：

```text
-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log
```

第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。

```sh
chmod [{ugoa}{+-=}{rwx}]文件或目录
chmod [mode=421 ] [文件或目录]
```

u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和)

r=4 w=2 x=1 rwx=4+2+1=7

常用参数：

```sh
-c 当发生改变时，报告处理信息
-R 处理指定目录以及其子目录下所有文件
```

权限范围：

```sh
u ：目录或者文件的当前的用户
g ：目录或者文件的当前的群组
o ：除了目录或者文件的当前用户或群组之外的用户或者群组
a ：所有的用户及群组
```

权限代号：

```sh
r ：读权限，用数字4表示
w ：写权限，用数字2表示
x ：执行权限，用数字1表示
- ：删除权限，用数字0表示
s ：特殊权限
```

实例：

```sh
# 修改文件使其所属主用户具有执行权限
chmod u+x houge.txt

# 修改文件使其所属组用户具有执行权限
chmod g+x houge.txt

# 修改文件所属主用户执行权限,并使其他用户具有执行权限
chmod u-x,o+x houge.txt

# 采用数字的方式，设置文件所有者、所属组、其他用户都具有可读可写可执行权限。
chmod 777 houge.txt

# 增加文件 t.log 所有用户可执行权限
chmod a+x t.log

# 撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息
chmod u=r t.log -c

# 给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限
chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c)

# 将 test 目录及其子目录所有文件添加可读权限
chmod u+r,g+r,o+r -R text/ -c
```

### [#](#_3、chown-命令) 3、chown 命令

chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。

```sh
chown [选项] [最终用户] [文件或目录] 功能描述:改变文件或者目录的所有者
-c 显示更改的部分的信息
-R 处理指定目录及子目录
```

**实例：**

```sh
# 修改文件所有者
chown testuser houge.txt

# 递归改变文件所有者和所有组
chown -R testuser:testuser xiyou/

# 改变拥有者和群组 并显示改变信息
chown -c mail:mail log2012.log

# 改变文件群组
chown -c :mail t.log

# 改变文件夹及子文件目录属主及属组为 mail
chown -cR mail: test/
```

### [#](#_4、chgrp-改变所属组) 4、chgrp 改变所属组

```sh
chgrp [最终用户组] [文件或目录] 功能描述:改变文件或者目录的所属组

# 修改文件的所属组
chgrp root houge.txt
```

## [#](#_7、磁盘查看和分区) 7、磁盘查看和分区

### [#](#_1、df-命令) 1、df 命令

df: disk free 空余磁盘

显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以 512 字节为单位进行显示：

```sh
-a 全部文件系统列表
-h 以方便阅读的方式显示信息
-i 显示inode信息
-k 区块为1024字节
-l 只显示本地磁盘
-T 列出文件系统类型
```

**实例：**

```sh
# 查看磁盘使用情况
df -h

# 显示磁盘使用情况
df -l

# 以易读方式列出所有文件系统及其类型
df -haT

# 查看当前文件夹所有文件大小
du -sh

# 查看指定文件下所有文件大小
du -h /data/

# 查看指定文件大小
du -h install.log

# 查指定文件夹大小
du -sh /data
```

### [#](#_2、du-命令) 2、du 命令

du: disk usage 磁盘占用情况

du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看：

命令格式：

**常用参数：**

```sh
-a 显示目录中所有文件大小
-k 以KB为单位显示文件大小
-m 以MB为单位显示文件大小
-g 以GB为单位显示文件大小
-h 以易读方式显示文件大小,以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示;
-s 仅显示总计
-c或--total  除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和
--max-depth=n 指定统计子目录的深度为第 n 层
```

**实例：**

```sh
# 查看当前用户主目录占用的磁盘空间大小
du -sh

# 以易读方式显示文件夹内及子文件夹大小
du -h scf/

# 以易读方式显示文件夹内所有文件大小
du -ah scf/

# 显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和
du -hc test/ scf/

# 输出当前目录下各个子目录所使用的空间
du -hc --max-depth=1 scf/
```

### [#](#_3、lsblk-查看设备挂载情况) 3、lsblk 查看设备挂载情况

lsblk 功能描述:查看设备挂载情况

```sh
-f 查看详细的设备挂载情况，显示文件系统信息
```

### [#](#_4、mount-umount-挂载-卸载) 4、mount/umount 挂载\*\*/\*\*卸载

对于 Linux 用户来讲，不论有几个分区，分别分给哪一个目录使用，它总归就是一个根 目录、一个独立且唯一的文件结构。

Linux 中每个分区都是用来组成整个文件系统的一部分，它在用一种叫做“挂载”的处理方法，它整个文件系统中包含了一整套的文件和目录，并将一个分区和一个目录联系起来，要载入的那个分区将使它的存储空间在这个目录下获得。

**挂载前准备(必须要有光盘或者已经连接镜像文件)**

![image-20220408164937081](https://xiaoxue-blog.oss-cn-shenzhen.aliyuncs.com/blog/202207071736755.png?x-oss-process=style/style_one)

![image-20220408164953977](https://xiaoxue-blog.oss-cn-shenzhen.aliyuncs.com/blog/202207071737749.png?x-oss-process=style/style_one)

**基本语法**

```sh
mount [-t vfstype] [-o options] device dir
umount 设备文件名或挂载点


-t vfstype  指定文件系统的类型，通常不必指定。mount 会自动选择正确的类 型。常用类型有:
			光盘或光盘镜像:iso9660
			DOS fat16 文件系统:msdos
            Windows 9x fat32 文件系统:vfat
            Windows NT ntfs 文件系统:ntfs
            Mount Windows 文件网络共享:smbfs
            UNIX(LINUX) 文件网络共享:nfs

-o options  主要用来描述设备或档案的挂接方式。
            常用的参数有:
            loop:用来把一个文件当成硬盘分区挂接上系统
            ro:采用只读方式挂接设备
            rw:采用读写方式挂接设备
            iocharset:指定访问文件系统所用字符集

device      要挂接(mount)的设备
dir         设备在系统上的挂接点(mount point)
```

```sh
# 挂载光盘镜像文件
mkdir /mnt/cdrom/   建立挂载点
mount -t iso9660 /dev/cdrom /mnt/cdrom/   设备/dev/cdrom 挂载到 挂载点 : /mnt/cdrom中
ll /mnt/cdrom/

# 卸载光盘镜像文件
umount /mnt/cdrom

# 设置开机自动挂载
vi /etc/fstab
```

添加红框中内容，保存退出。

![image-20220408170041298](https://xiaoxue-blog.oss-cn-shenzhen.aliyuncs.com/blog/202207071737579.png?x-oss-process=style/style_one)

### [#](#_5、fdisk-分区) 5、fdisk 分区

```sh
fdisk -l (功能描述:查看磁盘分区详情)
fdisk硬盘设备名 (功能描述:对新增硬盘进行分区操作)

-l 显示所有硬盘的分区列表
```

**该命令必须在 root 用户下才能使用**

```sh
Linux 分区
    Device:分区序列
    Boot:引导
    Start:从X磁柱开始
    End:到Y磁柱结束
    Blocks:容量
    Id:分区类型ID
    System:分区类型
分区操作按键说明
    m:显示命令列表
    p:显示当前磁盘分区
    n:新增分区
    w:写入分区信息并退出
    q:不保存分区信息直接退出
```

### [#](#_6、uname) 6、uname

```sh
# 查看 CentOS 系统的版本
cat /etc/redhat-release
# 查看内核版本
uname  -a
```

### [#](#_7、firewall-cmd) 7、firewall-cmd

```sh
# 查看防火墙状态
firewall-cmd --state
# 停止firewall
systemctl stop firewalld.service
# 禁止firewall开机启动
systemctl disable firewalld

# 查询端口是否开放
firewall-cmd --query-port=***/tcp
firewall-cmd --query-port=8848/tcp

# 开启端口
firewall-cmd --permanent--add-port=***/tcp

# 关闭端口
firewall-cmd --permanent--remove-port=***/tcp

# 在完成对端口的操作之后，需要重启防火墙
firewall-cmd --reload
```

### [#](#_8、内存大小) 8、内存大小

```sh
cat /proc/meminfo |grep MemTotal
```

### [#](#_9、centos-查看-cpu-核数、型号和主频) 9、Centos 查看 CPU 核数、型号和主频

```sh
cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c
```

## [#](#_8、时间日期相关) 8、时间日期相关

### [#](#_1、date-命令) 1、date 命令

显示或设定系统的日期与时间。

命令参数：

```sh
-d<字符串> 　显示字符串所指的日期与时间。字符串前后必须加上双引号。
-s<字符串> 　根据字符串来设置日期与时间。字符串前后必须加上双引号。
-u 　显示GMT。
%H 小时(00-23)
%I 小时(00-12)
%M 分钟(以00-59来表示)
%s 总秒数。起算时间为1970-01-01 00:00:00 UTC。
%S 秒(以本地的惯用法来表示)
%a 星期的缩写。
%A 星期的完整名称。
%d 日期(以01-31来表示)。
%D 日期(含年月日)。
%m 月份(以01-12来表示)。
%y 年份(以00-99来表示)。
%Y 年份(以四位数来表示)。
```

**实例：**

```sh
# 显示下一天
date +%Y%m%d --date="+1 day"  //显示下一天的日期

# -d参数使用
date -d "nov 22"  今年的 11 月 22 日是星期三
date -d '2 weeks' 2周后的日期
date -d 'next monday' (下周一的日期)
date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d
date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d
date -d last-month +%Y%m(上个月是几月)
date -d next-month +%Y%m(下个月是几月)
date -d '1 days ago' 功能描述:显示前一天时间
date -d '-1 days ago' 功能描述:显示明天时间
```

**date 设置系统时间**

```sh
date -s 字符串时间
date -s "2022-04-07 20:52:18"
```

### [#](#_2、cal-命令) 2、cal 命令

可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份：

常用参数：

```sh
-3 显示前一月，当前月，后一月三个月的日历
-m 显示星期一为第一列
-j 显示在当前年第几天
-y [year]显示当前年[year]份的日历
```

**实例：**

```sh
# 查看当前月的日历
cal

# 查看 2022 年的日历
cal 2022

# 显示指定年月日期
cal 9 2012

# 显示2013年每个月日历
cal -y 2013

# 将星期一做为第一列,显示前中后三月
cal -3m
```

## [#](#_9、用户管理命令) 9、用户管理命令

### [#](#_1、useradd-添加新用户) 1、useradd 添加新用户

```sh
useradd 用户名 (功能描述:添加新用户)
useradd -g 组名 用户名 (功能描述:添加新用户到某个组)
```

### [#](#_2、passwd-设置用户密码) 2、passwd 设置用户密码

```sh
passwd 用户名 (功能描述:设置用户密码)
```

### [#](#_3、id-查看用户是否存在) 3、id 查看用户是否存在

### [#](#_4、cat-etc-passwd查看创建了哪些用户) 4、cat /etc/passwd 查看创建了哪些用户

### [#](#_5、su-切换用户) 5、su 切换用户

```sh
su 用户名称 (功能描述:切换用户，只能获得用户的执行权限，不能获得环境变量)
su - 用户名称 (功能描述:切换到用户并获得该用户的环境变量及执行权限)
```

### [#](#_6、userdel-删除用户) 6、userdel 删除用户

```sh
userdel 用户名 功能描述:删除用户但保存用户主目录
userdel -r 用户名 功能描述:用户和用户主目录，都删除

# 删除用户但保存用户主目录
userdel testuser

# 删除用户和用户主目录，都删除
userdel -r testuser
```

### [#](#_7、who-查看登录用户信息) 7、who 查看登录用户信息

```sh
whoami (功能描述:显示自身用户名称)
who am i (功能描述:显示登录用户的用户名以及登陆时间)
```

### [#](#_8、sudo-设置普通用户具有-root-权限) 8、sudo 设置普通用户具有 root 权限

```sh
# 添加 testuser 用户，并对其设置密码。
useradd testuser
passwd testuser

# 修改配置文件
vi /etc/sudoers
修改 /etc/sudoers 文件，找到下面一行(91 行)，在 root 下面添加一行，如下所示:
## Allow root to run any commands anywhere
root       ALL=(ALL)     ALL
testuser   ALL=(ALL)     ALL

或者配置成采用 sudo 命令时，不需要输入密码
# Allow root to run any commands anywhere
root       ALL=(ALL)     ALL
testuser   ALL=(ALL)     NOPASSWD:ALL

修改完毕，现在可以用 testuser 帐号登录，然后用命令 sudo ，即可获得 root 权限进行
```

```sh
# 操作
# 用普通用户在/opt 目录下创建一个文件夹
sudo mkdir module
chown testuser:testuser module/
```

### [#](#_9、usermod-修改用户) 9、usermod 修改用户

```sh
-g 修改用户的初始登录组，给定的组必须存在。默认组 id 是 1。
usermod -g 用户组 用户名

# 将用户加入到用户组
usermod -g root zhubajie
```

## [#](#_10、用户组管理命令) 10、用户组管理命令

每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，

如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。

用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对 /etc/group 文件的更新。

### [#](#_1、groupadd-新增组) 1、groupadd 新增组

```sh
groupadd 组名

# 添加一个xitianqujing组
groupadd xitianqujing
```

### [#](#_2、groupdel-删除组) 2、groupdel 删除组

```sh
groupdel 组名

# 删除xitianqujing组
groupdel xitianqujing
```

### [#](#_3、groupmod-修改组) 3、groupmod 修改组

```sh
groupmod -n 新组名 老组名

# 修改xitianqujing组名称为xitian
groupmod -n xitian xitianqujing
```

### [#](#_4、cat-etc-group查看创建了哪些组) 4、cat /etc/group 查看创建了哪些组

## [#](#_11、压缩和解压类) 11、压缩和解压类

### [#](#_1、gzip-gunzip-压缩) 1、gzip/gunzip 压缩

gzip 文件 (功能描述:压缩文件，只能将文件压缩为\*.gz 文件)

gunzip 文件.gz (功能描述:解压缩文件命令)

-   只能压缩文件不能压缩目录
-   不保留原来的文件
-   同时多个文件会产生多个压缩包

```sh
# gzip压缩
gzip houge.txt

# gunzip解压缩文件
gunzip houge.txt.gz
```

### [#](#_2、zip-unzip-压缩) 2、zip/unzip 压缩

```sh
zip [选项] XXX.zip 将要压缩的内容 功能描述:压缩文件和目录的命令
unzip [选项] XXX.zip 功能描述:解压缩文件
```

```sh
-r 压缩目录
-d<目录> 指定解压后文件的存放目录
```

zip 压缩命令在 windows/linux 都通用，可以压缩目录且保留源文件。

```sh
# 压缩 houge.txt 和bailongma.txt，压缩后的名称为mypackage.zip
touch bailongma.txt
zip mypackage.zip houge.txt bailongma.txt

# 解压 mypackage.zip
unzip mypackage.zip

# 解压mypackage.zip到指定目录-d
unzip mypackage.zip -d /opt
```

### [#](#_3、tar-命令) 3、tar 命令

用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。

弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件

**常用参数：**

```sh
-c 建立新的压缩文件
-f 指定压缩文件
-r 添加文件到已经压缩文件包中
-u 添加改了和现有的文件到压缩包中
-x 从压缩包中抽取文件
-t 显示压缩文件中的内容
-z 支持gzip压缩
-j 支持bzip2压缩
-Z 支持compress解压文件
-v 显示操作过程
```

有关 gzip 及 bzip2 压缩:

```sh
gzip 实例：压缩 gzip fileName .tar.gz 和.tgz  解压：gunzip filename.gz 或 gzip -d filename.gz
          对应：tar zcvf filename.tar.gz     tar zxvf filename.tar.gz

bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2
       对应：tar jcvf filename.tar.gz         解压：tar jxvf filename.tar.bz2
```

**实例：**

（1）将文件全部打包成 tar 包

```text
tar -cvf log.tar 1.log,2.log 或tar -cvf log.*
```

（2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩

```text
tar -zcvf /tmp/etc.tar.gz /etc
```

（3）查看刚打包的文件内容（一定加 z，因为是使用 gzip 压缩的）

```text
tar -ztvf /tmp/etc.tar.gz
```

（4）要压缩打包 /home, /etc ，但不要 /home/dmtsai

```text
tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc
```

```sh
# 压缩多个文件
tar -zcvf houma.tar.gz houge.txt bailongma.txt

# 压缩目录
tar -zcvf xiyou.tar.gz xiyou/

# 解压到当前目录
tar -zxvf houma.tar.gz

# 解压到指定目录
tar -zxvf houma.tar.gz -C /opt
```

## [#](#_12、crontab-系统定时任务) 12、crontab 系统定时任务

### [#](#_1、crontab-服务管理) 1、crontab 服务管理

```sh
# 重新启动 crond 服务
systemctl restart crond
```

### [#](#_2、crontab-定时任务设置) 2、crontab 定时任务设置

```sh
crontab [选项]

-e 编辑 crontab 定时任务
-l 查询 crontab 任务
-r 删除当前用户所有的 crontab 任务

crontab -e
进入 crontab 编辑界面。会打开 vim 编辑你的工作。
* * * * * 执行的任务
```

| 项目       | 含义                 | 范围                     |
| ---------- | -------------------- | ------------------------ |
| 第一个“\*” | 一小时当中的第几分钟 | 0-59                     |
| 第二个“\*” | 一天当中的第几小时   | 0-23                     |
| 第三个“\*” | 一个月当中的第几天   | 1-31                     |
| 第四个“\*” | 一年当中的第几月     | 1-12                     |
| 第五个“\*” | 一周当中的星期几     | 0-7(0 和 7 都代表星期日) |

| 特殊符号 | 含义                                                                                                            |
| -------- | --------------------------------------------------------------------------------------------------------------- |
| \*       | 代表任何时间。比如第一个“\*”就代表一小时中每分钟都执行一次的意思。                                              |
| ，       | 代表不连续的时间。比如“0 8,12,16 \* \* \* 命令”，就代表在每天的 8 点 0 分，12 点 0 分，16 点 0 分都执行一次命令 |
| \-       | 代表连续的时间范围。比如“0 5 \* \* 1-6 命令”，代表在 周一到周六的凌晨 5 点 0 分执行命令                         |
| \*/n     | 代表每隔多久执行一次。比如“\*/10 \* \* \* \* 命令”，代 表每隔 10 分钟就执行一遍命令                             |

**特定时间执行命令**

| 时间                  | 含义                                                                                                                                  |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| 45 22 \* \* \*命令    | 每天 22 点 45 分执行命令                                                                                                              |
| 0 17 \* \* 1 命令     | 每周 1 的 17 点 0 分执行命令                                                                                                          |
| 0 5 1,15 \* \*命令    | 每月 1 号和 15 号的凌晨 5 点 0 分执行命令                                                                                             |
| 40 4 \* \* 1-5 命令   | 每周一到周五的凌晨 4 点 40 分执行命令                                                                                                 |
| \*/10 4 \* \* \* 命令 | 每天的凌晨 4 点，每隔 10 分钟执行一次命令                                                                                             |
| 0 0 1,15 \* 1 命令    | 每月 1 号和 15 号，每周 1 的 0 点 0 分都会执行命令。注 意:星期几和几号最好不要同时出现，因为他们定义的都 是天。非常容易让管理员混乱。 |

```sh
# 每隔 1 分钟，向/root/bailongma.txt 文件中添加一个 11 的数字
*/1 * * * * /bin/echo ”11” >> /root/bailongma.txt
```

## [#](#_13、jar包相关) 13、JAR 包相关

### [#](#_1、启动jar包) 1、启动 jar 包

```sh
nohup java -jar XX.jar -Xms128M -Xmx1024M -server.port=9002 XX.jar > XX.out 2>&1 &

#简化版
nohup java -jar /home/test1.jar  >/home/log/test1.txt &
nohup：忽略SIGHUP信号,关闭shell后，进程还是存在的。
java：启动程序
-jar：启动类型
-Xms128M -Xmx1024M：指定内存，Xms一般为最大内存的1/64,Xmx一般为最大内存的1/4
-server.port=9002：指定端口
XX.jar：jar包路径

>：日志重定向，用>时清空日志文件后前面会产生空白，可以用>>
XX.out：输出日志路径，不要日志可以输出到/dev/null
2>&1：标准输出与错误输出
&：后台运行，即使你用ctrl C,照样运行，但是要注意，如果你直接关掉shell后，进程同样消失。可见，&的后台并不硬（因为对SIGHUP信号不免疫）。
```

### [#](#_2、启动脚本) 2、启动脚本

```sh
SERVCER_JAR=`ls -R |grep *.jar |head -n 1`
DEPLOY_DIR=`pwd`
STDOUT_FILE=$DEPLOY_DIR/stdout.log


PID=`ps -ef | grep java | grep "$SERVCER_JAR" |awk '{print $2}'`
if [ -z "$PID" ]; then
    echo -e "\033[31mhe $SERVCER_JAR not started!开始启动... \033[0m "
else
    echo -e "echo -e "\033[31m $SERVCER_JAR 已经启动 开始关闭 并重启\033[0m""
    echo -e "\033[32mhe Stopping the service $SERVCER_JAR ... \033[0m"
    kill -9 $PID > /dev/null 2>&1
    echo -e "OK!"
    echo -e "PID: $PID"
fi

echo -e "\033[32mhe start the service $SERVCER_JAR \033[0m "
nohup java -Xms4g -Xmx4g -XX:+UseG1GC -Dfile.encoding=utf-8 -Dspring.cloud.nacos.config.server-addr=192.168.143.17:8848 -Dspring.cloud.nacos.config.namespace=tcm -Dspring.cloud.nacos.config.group=prod -Dspring.cloud.nacos.config.username=nacos -Dspring.cloud.nacos.config.password=GSsWjWNAcOs -Dspring.cloud.nacos.discovery.server-addr=192.168.143.17:8848 -Dspring.cloud.nacos.discovery.username=nacos -Dspring.cloud.nacos.discovery.password=GSsWjWNAcOs -Dspring.cloud.nacos.discovery.namespace=be1605e4-7e68-4f20-8eb5-df03d0a2de85 -jar $SERVCER_JAR  > $STDOUT_FILE 2>&1 &
tail -f $DEPLOY_DIR/stdout.log
```

### [#](#_3、检查服务脚本) 3、检查服务脚本

```sh
SERVCER_JAR=`ls -R |grep *.jar |head -n 1`
PID=`ps -ef | grep java | grep "$SERVCER_JAR" |awk '{print $2}'`
if [ -z "$PID" ]; then
        echo -e "\033[31mhe $SERVCER_JAR not started!\033[0m"
else
        echo -e "\033[32mhe $SERVCER_JAR is started!\033[0m"
fi
```

### [#](#_4、停止服务脚本) 4、停止服务脚本

```sh
#!/bin/bash
export PATH=$JAVA_HOME/bin:$PATH
java -version
cd `dirname $0`
BIN_DIR=`pwd`
DEPLOY_DIR=`pwd`
SERVCER_JAR=`ls |grep *.jar |head -n 1`
DEPLOY_DIR=`pwd`
CONF_DIR=$DEPLOY_DIR




PIDS=`ps -ef | grep java | grep "$SERVCER_JAR" |awk '{print $2}'`
if [ -z "$PIDS" ]; then
    echo "ERROR: The $SERVCER_JAR does not started!"
    exit 1
fi


echo -e "Stopping the service $SERVCER_JAR ...\c"
for PID in $PIDS ; do
    kill -9 $PID > /dev/null 2>&1
done

COUNT=0
while [ $COUNT -lt 1 ]; do
    echo -e ".\c"
    sleep 1
    COUNT=1
    for PID in $PIDS ; do
        PID_EXIST=`ps -f -p $PID | grep java`
        if [ -n "$PID_EXIST" ]; then
            COUNT=0
            break
        fi
    done
done

sleep 3

```

41
