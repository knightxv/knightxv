---
title: 进程调度策略
date: 2023-02-02 20:09:06
permalink: /pages/646840/
categories:
  - 云原生
  - 系统编程
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
# 进程调度（算法）策略

当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。

-   先来先服务调度算法
-   最短作业优先调度算法
-   高响应比优先调度算法
-   时间片轮转调度算法
-   最高优先级调度算法
-   多级反馈队列调度算法

## 先来先服务（FCFS，First Come First Serve）：

非抢占式的调度算法，按照请求的顺序进行调度，每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。

有利于长作业，适用于 CPU 繁忙型作业的系统；但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对 I/O 密集型进程也不利，因为这种进程每次进行 I/O 操作之后又得重新排队。

## 短作业优先(SJF,Shortest Job First)：

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**最短作业优先（Shortest Job First, SJF）**调度算法同样也是顾名思义，它会优先选择运行时间最短的进程来运行，这有助于提高系统的吞吐量。

但显然对长作业不利，很容易造成一种极端现象。

比如，一个长作业在就绪队列等待运行，而这个就绪队列有非常多的短作业，那么就会使得长作业不断的往后推，周转时间变长，致使长作业长期不会被运行。

## 最短剩余时间优先(SRTN)：

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

## 高响应比优先调度算法(HRRN):

前面的「先来先服务调度算法」和「最短作业优先调度算法」都没有很好的权衡短作业和长作业。
那么，高响应比优先 （Highest Response Ratio Next, HRRN）调度算法主要是权衡了短作业和长作业。每次进行进程调度时，先计算「响应比优先级」，然后把「响应比优先级」最高的进程投入运行，「响应比优先级」的计算公式：

```shell
优先权 = (等待时间+要求服务时间)/ 要求服务时间
```

从上面的公式，可以发现：

如果两个进程的「等待时间」相同时，「要求的服务时间」越短，「响应比」就越高，这样短作业的进程容易被选中运行；

如果两个进程「要求的服务时间」相同时，「等待时间」越长，「响应比」就越高，这就兼顾到了长作业进程，因为进程的响应比可以随时间等待的增加而提高，当其等待时间足够长时，其响应比便可以升到很高，从而获得运行的机会；

> 上述几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，
> 但是不关心“响应时间”，也并不区分任务的紧急程度，因此对于用户来说，交互性很糟糕。因此这三种算法一般适合用于早期的批处理系统，当然，先来先服务算法也常结合其他的算法使用，在现在也扮演着很重要的角色。

`而适合用于交互式系统的调度算法将在下面介绍`.

## 时间片轮转（RR,Round-Robin）

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

每个进程被分配一个时间段，称为时间片（Quantum），即允许该进程在该时间段中运行。

如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；
如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；
另外，时间片的长度就是一个很关键的点：

-   因为进程切换都要保存进程的信息并且载入新进程的信息，
-   如果时间片设得太短会导致过多的进程上下文切换，在进程切换上就会花过多时间，降低了 CPU 效率；
-   如果设得太长又可能引起对短作业进程的响应时间变长。

通常时间片设为 20ms~50ms 通常是一个比较合理的折中值。

## 优先级调度：

前面的「时间片轮转算法」做了个假设，即让所有的进程同等重要，也不偏袒谁，大家的运行时间都一样。

但是，对于多用户计算机系统就有不同的看法了，它们希望调度是有优先级的，即希望调度程序能从就绪队列中选择最高优先级的进程进行运行，这称为最高优先级（Highest Priority First，HPF）调度算法。

为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

进程的优先级可以分为，静态优先级或动态优先级：

-   静态优先级：创建进程时候，就已经确定了优先级了，然后整个运行时间优先级都不会变化；
-   动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。

该算法也有两种处理优先级高的方法，非抢占式和抢占式：

-   非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程。
-   抢占式：当就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程运行。

但是依然有缺点，可能会导致低优先级的进程永远不会运行。

## 多级反馈队列调度算法

-   先来先服务算法的优点是公平
-   短作业优先算法的优点是能尽快处理完短作业，平均等待/周转时间等参数很优秀
-   时间片轮转调度算法可以让各个进程得到及时的响应
-   优先级调度算法可以灵活地调整各种进程被服务的机会
-   多级反馈队列调度算法是对其他算法的一个折中权衡

多级反馈队列（Multilevel Feedback Queue）调度算法是「时间片轮转算法」和「最高优先级算法」的综合和发展。

顾名思义：

-   「多级」表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。
-   「反馈」表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列；

![](https://cdn.staticaly.com/gh/knightxv/image-hosting@master/20230202/xt-10.2sw23g9kyai0.webp)

来看看，它是如何工作的：

-   设置了多个队列，赋予每个队列不同的优先级，每个队列优先级从高到低，时间片从小到大；

-   新的进程会被放入到第一级队列的末尾，按先来先服务的原则排队等待被调度，如果在第一级队列规定的时间片没运行完成，则将其转入到第二级队列的末尾，如果此时已经是在最下级的队列，则重新放回该队列队尾，以此类推，直至完成；

-   当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行时，有新进程进入较高优先级的队列，则停止当前运行的进程并将其移入到原队列末尾，接着让较高优先级的进程运行；

可以发现，对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的兼顾了长短作业，同时有较好的响应时间。
