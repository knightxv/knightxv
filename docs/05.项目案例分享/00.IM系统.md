---
title: IM系统
date: 2023-01-06 23:00:16
permalink: /pages/8c4a48/
titleTag: 精选
sticky: 1
categories:
  - 项目案例分享
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
# IM 系统架构

## 整体架构

![IM系统架构图](https://cdn.staticaly.com/gh/knightxv/image-hosting@master/20230118/微信图片_20230118215118.3no2ng0ajne0.webp)

服务端由接入层、逻辑层和存储层组成，好处在于各个层次能够依据业务特点专注于自己的事情，提高系统复用性，降低业务间的耦合。

（1）接入层：消息通过 websocket 协议接入，其他通过 http/https 协议接入，消息是高频及核心功能，通过双协议路由，体现了轻重分离的设计思想。

（2）逻辑层：通过 rpc 实现无状态逻辑服务，易于平行扩展，消息通过 MQ 解耦。

（3）存储层：

    数据分层存储，充分利用不同存储组件的特性

-   redis 存储 token 和 seq；
-   mongodb 存储离线消息，并定时删除
-   mysql 存储全量历史消息以及用户相关资料

（4）Consul：服务注册和发现、以及分布式配置中心。

## 消息架构

### 私聊

消息模型采用经典的收件箱模型，并通过全局 seq 做消息对齐，这里带来架构的简化.

以下我们简单讲解消息如何发送，系统如何简单解耦，接收方如何实时收到消息，并如何利用 seq 做全局消息对齐，确保消息百分百可达。

（1）用户 A 发送消息，msg_gateway 进行消息拆分，并落地 MQ，MQ 根据 userId 写入不同的 partition 后返回给 A 成功，消息发送流程结束

（2）msg_transfer 通过 MQ 消费者监听消息达到，通过 redis 增加 userId 对应的 seq，并把 seq 和消息关联后写入 mongodb，离线消息存储，比如用户不在线或者推送失败时同步消息使用。写入成功后，再调用 pusher 推送，根据 B 所连接的 msg_gateway，进行消息推送（由于网络波动或者 B 不在线等原因，可能会推送失败）。

（3）客户端在任何有重连动作（包括重新登录、网络波动等）发生时，首先会获取自身在服务端最大的 seq，和本地 seq 做差值对比，把差值消息通过接口主动拉取到本地，这样完成了本地和服务端消息对齐。

### 群聊

-   当群的规模比较小（小于 500 人）的时候，采用私聊的方式进行推送。

    用户 A 发送群聊消息，msg_gateway 获取群成员并扩散，把消息放入到群成员的收件箱中，按照私聊的方式进行同步（类似于用户 A 向每个成员发送私聊数据）。

-   当群规模比较大（大于 500 人），就不能按照写扩散的形式进行推送了。这时候就需要新建一个收件箱，用户主动到这个收件箱里面同步。

### 读扩散问题

当用户加的大群（大于 500 人）比较多，每个会话的 Timeline 中保存了这个会话的全量消息。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。

解决方案：

> 整体采用推拉结合模式：有新消息时服务器会先推一个有新消息的通知给前端，前端接收到通知后就向服务器拉取消息。

具体流程如下：
（1）当用户登录的时候，客户端发送要监听的群 ID 以及所对应的本地 req 进行初始化，服务端查询对应的最新 req，对比出差值，把差值推送给客户端。客户端主动同步。
（2）初始化完成后，会通过 redis 的订阅发布模式，监听群的消息变更，当监听到群有`有新消息的通知`时，通过 msg_gateway 通知给用户。
