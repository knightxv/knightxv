---
title: 数据库分库分表
date: 2023-01-06 23:01:31
permalink: /pages/1a65ee/
categories:
  - 项目案例分享
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
## 为什么要分库分表？

-   分表

    我们平时做项目开发。一开始，通常都先用一张数据表，随着业务的发展，我们表中的数据量会变的越来越大，一般来说数据表写到 2kw 条数据之后，底层 B+树的层级结构就会变高，不同层级的数据页一般都放在磁盘里不同的地方，换言之，磁盘 IO 就会增多，带来的便是查询性能变差。我们为了解决单表的查询性能问题，一般会进行分表操作。

-   分库

    同时我们业务的用户活跃度也会越来越高，并发量级不断加大，那么可能会达到单个数据库的处理能力上限。此时我们为了解决数据库的处理性能瓶颈，一般会进行分库操作。

## 如何制定分库分表方案？

### 可持续性

在对数据库进行分库分表前，要先考虑方案的可持续性。
那何为可持续性?其实就是：**业务数据量级和业务流量未来进一步升高达到新的量级的时候，我们的分库分表方案可以持续使用**。

一个通俗的案例，假定当前我们分库分表的方案为 10 库 100 表，那么未来某个时间点，若 10 个库仍然无法应对用户的流量压力，或者 10 个库的磁盘使用即将达到物理上限时，我们的方案能够进行平滑扩容。

### 数据偏斜

一个良好的分库分表方案，它的数据应该是需要比较均匀的分散在各个库表中的。

如果我们进行一个拍脑袋式的分库分表设计，很容易会遇到以下类似问题：

某个数据库实例中，部分表的数据很多，而其他表中的数据却寥寥无几，业务上的表现经常是延迟忽高忽低，飘忽不定。

数据库集群中，部分集群的磁盘使用增长特别块，而部分集群的磁盘增长却很缓慢。每个库的增长步调不一致，这种情况会给后续的扩容带来步调不一致，无法统一操作的问题。

这边我们定义分库分表最大数据偏斜率为：

```text
(数据量最大样本-数据量最小样本)/数据量最小样本。
```

一般来说，如果我们的最大数据偏斜率在 5% 以内是可以接受的。

## 常见的分库分表方案

### [#](Range范围分表)一、Range 范围分表

顾名思义，该方案根据数据范围划分数据的存放位置。通过数据的范围进行分库分表，该方案是最朴实的一种分库方案，它也可以和其他分库分表方案灵活结合使用。

时下非常流行的分布式数据库：TiDB 数据库，针对 TiKV 中数据的打散，也是基于 Range 的方式进行，将不同范围内的[StartKey，EndKey)分配到不同的 Region 上。

我们假设每张分表能放 2kw 行数据。那 user0 就放主键 id 为 1~2kw 的数据。`user1`就放 id 为`2kw+1 ~ 4kw`，`user2`就放 id 为`4kw+1 ~ 6kw`， `userN`就放 `2N kw+1 ~ 2(N+1)kw`。这样读取数据只需根据`ID/2kw`就可以索引到具体的表。

下面我们看看该方案的缺点：

-   最明显的就是数据热点问题，新写入的数据一般都会落到某一张表上，并且新写入的数据读取的频率也会比较高，那这张表就会出现读写热点问题。
-   新库和新表的追加问题。一般我们线上运行的应用程序是没有数据库的建库建表权限的，故我们需要提前将新的库表提前建立，防止线上故障。这点非常容易被遗忘，尤其是稳定跑了几年没有迭代任务，或者人员又交替频繁的模块

### [#](Hash取模分库分表)二、Hash 取模分库分表

Hash 分库分表是最大众最普遍的方案,主要的核心思想就是先计算 hash 值，然后通过 hash 取模的方式来计算分片的位置。

```bash
# 获取Hash值
int hash = userId.hashCode();
# 总分片数
int sumSlot = DB_CNT * TBL_CNT;
# 分片序号
int slot = Math.abs(hash % sumSlot);
# 根据分片序号获取数据库和表的idx
int dbIdx = slot / TBL_CNT; # 数据库idx
int tblIdx = slot % TBL_CNT; # 表idx
```

举例：以 10 库（每库 10 表）共 100 表为例，通过翻倍扩容后，变成 20 库 200 表。
此时有两个 Hash 值分别为 101 和 201

翻倍前

```bash
DB_CNT = 10
TBL_CNT = 10
# 总分片数
int sumSlot = DB_CNT * TBL_CNT; # 100
# 分片序号
int slot = Math.abs(hash % sumSlot);
# 101 % 100 = 1
# 201 % 100 = 1
# 重新修改二次求值方案
int dbIdx = slot / TBL_CNT; # 数据库idx
# 1 / 10 = 0
# 1 / 10 = 0
int tblIdx = slot % TBL_CNT; # 表idx
# 1 % 10 = 1
# 1 % 10 = 1
```

翻倍后

```bash
DB_CNT = 20
TBL_CNT = 10
# 总分片数
int sumSlot = DB_CNT * TBL_CNT; # 200
# 分片序号
int slot = Math.abs(hash % sumSlot);
# 101 % 200 = 101
# 201 % 200 = 1
# 重新修改二次求值方案
int dbIdx = slot / TBL_CNT; # 数据库idx
# 101 / 10 = 10
# 1 / 10 = 0
int tblIdx = slot % TBL_CNT; # 表idx
# 101 % 10 = 1
# 1 % 10 = 1
```

通过翻倍扩容后，我们的表序号一定维持不变，库序号可能还是在原来库，也可能平移到了新库中(原库序号加上原分库数)，完全符合我们需要的扩容持久性方案。

### [#](基因法)三、基因法

使用相对独立的 Hash 值来计算库序号和表序号。

这也是一种常用的方案，我们称为基因法，即使用原分片键中的某些基因(例如前四位)作为库的计算因子，而使用另外一些基因作为表的计算因子。

```java
int dbIdx = Math.abs(userId.substring(0, 4).hashCode() % DB_CNT );
int tblIdx = Math.abs(userId.hashCode() % TBL_CNT);
```

## 读扩散问题

我们上面提到的好几种分表方式，都用了 id 这一列作为分表的依据，这其实就是所谓的分片键。实际上我们一般也是用的数据库主键作为分片键。

这样，理想情况下我们已知一个 id，不管是根据哪种规则，我们都能很快定位到该读哪个分表。但很多情况下，我们的查询又不是只查主键，而是通过别的字段去查询。而其他字段又没有分片索引，没法定位到具体要到哪个分表上去执行 sql，而如果一个库一个库去查询就会引发`读扩散`问题。这种场合，`倒排索引`的形式来加速数据查询。

举个例子，我同样是一行数据 id,name,age。在 mysql 里，你得根据 id 分片，如果要支持 name 和 age 的查询，可以使用`elasticSearch`，它会在它内部以 id 分片键进行分片，同时还能建一个 name 到 id，和一个 age 到 id 的倒排索引,先用 name 查到对应的 id，再拿 id 去获取具体的数据。这其实就像是建立了一个新的索引一样。

而且将 mysql 接入 es 也非常简单，我们可以通过开源工具 canal 监听 mysql 的 binlog 日志变更，再将数据解析后写入 es，这样 es 就能提供近实时的查询能力。

![在这里插入图片描述](https://cdn.xiaobaidebug.top/mysql%E5%90%8C%E6%AD%A5es.drawio.png)
