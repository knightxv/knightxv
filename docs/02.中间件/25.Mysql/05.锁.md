---
title: 锁
date: 2020-02-02 20:14:24
permalink: /pages/d385b5/
categories:
  - 中间件
  - Mysql
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
# 锁

根据加锁范围, MySQL 里的锁大致分成 **全局锁** 、**表锁** 和 **行锁**

### 全局锁

全局锁就是对整个数据库实例加锁. MySQL 提供了一个加全局读锁的方法, `Flush tables with read lock(FTWRL)` 使整个库都处于只读状态. 一般用于全局备份.

### 表锁

InnoDB 中的表锁十分鸡肋, 一般都是通过 `MySQL` 的 server 层下的 **元数据锁 (Metadata Lock)** 来实现当对表执行 DDL 语句时, 使得其他事务阻塞. InnoDB 厉害之处是实现了更细粒度的行锁.

### 行锁

**在 InnoDB 事务中，行锁通过给索引上的索引项加锁来实现。这意味着只有通过索引条件检索数据，InnoDB 才使用行级锁，否则将使用表锁。**
行级锁定同样分为两种类型：**共享锁**和**排他锁**，以及加锁前需要先获得的意向共享锁和意向排他锁。

-   共享锁：读锁，允许其他事务再加 S 锁，不允许其他事务再加 X 锁，即其他事务只读不可写。select...lock in share mode 加锁。
-   排它锁：写锁，不允许其他事务再加 S 锁或者 X 锁。insert、update、delete、for update 加锁。

**行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

#### 行锁的实现算法

-   **Record Lock 记录锁：**单个行记录上的锁，总是会去锁住索引记录。
    仅仅只是把一条记录给锁上, 当一个事务获取了记录的 S 锁, 其他事务也能够获得 S 锁, 但无法获得 X 锁; 而一个事务获取了记录的 X 锁, 则其他事务不能获得 S 锁和 X 锁.
-   **Gap Lock 间隙锁 ** 解决幻读
    在 RR 级别下产生幻读问题一般有两种解决方案: MVCC 或加锁.
    假设有记录 id = [1, 3, 4], 这时有事务想在[1, 3]之间插入一个 id = 2 的记录, 可能产生幻读, 所以给 id = 3 的记录前的间隙加上了 Gap Lock, 意思是在释放这个 Gap Lock 之前都不允许其他事务在这条记录前插入数据. 那如果在最后一条后插入数据呢 ? 在表最后会有一条伪记录 Supremum, 对 Supremum 加 Gap Lock,   这样就会防止在最后插入记录造成的幻读.
-   **Next-Key Lock**
    有时, 既想锁住某条记录, 又想阻止在记录前的间隙插入新记录. 于是就有了 Next-Key Lock. 本质就是一个 Record Lock + Gap Lock，左开又闭.
-   **Insert Intention Lock 插入意向锁**
    若插入位置已被别的事务加了 Gap Lock, 则事务在等待时也需要在内存中生成一个锁结构, 被称为 插入意向锁. 当 Gap Lock 释放的时候,插入意向锁就会将等待事务中锁结构内的 is_waiting 的状态改为 false, 然后开始继续往下执行插入操作.
-   **隐式锁**
    隐式锁其实是一种延迟生成锁结构的方案, 通过判断事务 id, 确定两个并发事务之间是否真的有必要加锁, 若需要, 则会生成锁结构, 然后进入等待; 不需要, 那么就没必要浪费内存去对事务生成锁结构, 降低维护成本. 类似于乐观锁实现.

### 锁之于隔离性

大致介绍了下锁，可以看到。有了锁，当某事务正在写数据时，其他事务获取不到写锁，就无法写数据，一定程度上保证了事务间的隔离
