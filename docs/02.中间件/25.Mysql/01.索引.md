---
title: 索引
date: 2020-02-02 20:14:23
permalink: /pages/ba6c1f/
categories:
  - 中间件
  - Mysql
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
# 索引

## 索引种类

-   **主键索引**的叶子节点存储的是整行数据. 在 InnoDB 里, 主键索引也被称为**聚簇索引**
-   **非主键索引**的叶子节点存储的是主键的值. 在 InnoDB 里, 非主键索引也被称为**二级索引 / 非聚簇索引**

## 回表

当执行 `SELECT * FROM t WHERE id = 500` 时, 即主键查询方式, 则需要搜索 ID 这颗 B+树; 当执行 `SELECT * FROM t WHERE k = 5` 时, 即普通索引查询方式, 则先在 k 这棵树查找到主键的值, 再从 ID 这棵树中查找到对应的行.

当我们执行 SQL 搜索数据时, 如果需要先从非主键索引中查询到主键的值, 再从主键索引中查询到对应的数据, 这个过程就被称为**回表**. 所以应该尽量使用主键查询.

## 索引维护 (页分裂与页合并)

B+树为了有序性, 需要对插入和删除数据时做出对应的维护. 当插入数据时, 如在上图中插入 ID=400 的数据, 那么从逻辑上来说, 需要移动后面的数据, 空出位置.

若此时 R5 所在数据页满了, 则需要申请一个新的数据页, 然后移动部分数据到新数据页中, 这个过程被称为**页分裂**. 页分裂影响了数据页的空间利用率, 而且在分裂过程中, 性能也会有所影响.

若相邻两个数据页因为删除导致利用率很低后, 那么会将这两个数据页的数据合并到一个数据页中, 这个过程被称为**页合并**. 即页分裂的逆过程.

## 覆盖索引

如果执行了语句 `SELECT id FROM t WHERE k between 3 and 5` 时, 只需要查询 id 的值, 而 id 已经在 k 的索引树上, 所以不需要再回表去查询整行, 直接返回查询结果, 索引 k 已经覆盖了这条 SQL 查询的需求, 被称为 **覆盖索引**. 覆盖索引能够减少树的搜索次数, 不需要再次回表查询整行, 所以是一个常用的性能优化手段.

## 最左前缀原则

**最左前缀原则** 就是利用索引列中最左的字段优先进行匹配

|         | **TYPE** | **INDEX**       |
| ------- | -------- | --------------- |
| id      | int      | id(primary key) |
| id_card | varchar  | id_card         |
| name    | varchar  | (name, age)     |
| age     | int      |                 |
| ismale  | tinyint  |                 |

若有如上表结构, 对于 INDEX(name, age)来说, 索引树结构如下, 可以看到, 索引项是按照索引定义里面出现的顺序排序的.

对于 SQL 语句 `SELECT * FROM t WHERE name LIKE '张%'` 来说, 也是能够用到 INDEX(name, age)这个索引的, 只需检索到第一个姓为张的人, 之后向后遍历即可, 所以可以利用最左前缀来加速检索. **最左前缀**可以是**联合索引的最左 N 个字段**, 也可以是**字符串索引的最左 M 个字符**.

其效果和单独创建一个 INDEX(name)的效果是一样的, 如果你想使用 INDEX(name, age)也想让 name 也拥有索引 INDEX(name), 那么只需保留前者即可, **若通过调整索引字段的顺序, 可以少维护一个索引树, 那么这个顺序就是需要优先考虑采用的**. 但如果也有 SQL 语句条件类似 `WHERE age = 1` , 那么最好再维护一个 INDEX(age)的索引.

## 前缀索引

在对字符串创建索引, 如 INDEX(name)中, 若字符串非常大, 那么响应的空间使用和维护开销也非常大, 就可以**使用字符串从左开始的部分字符创建索引**, 减少空间和维护的成本, 但是也会降低索引的选择性. **索引的选择性**指的是 : 不重复的索引值和数据表的记录总数(#T)的比值, 范围为 1/#T 到 1 之间, 索引选择性越高则查询效率越高. 对于 BLOB, TEXT, VARCHAR 等类型的列, 必须使用前缀索引, MySQL 不允许索引这些列的完整长度.

1. 先计算完整列的选择性 `SELECT COUNT(DISTINCT name)/COUNT(1) FROM t`
2. 在计算不同前缀长度 N 的选择性 `SELECT COUNT(DISCTINCT LEFT(name, N)) / COUNT(1) FROM t`
3. 看哪个 N 更靠近 1, 进行索引的创建

## 索引下推

对于 SQL 语句 `SELECT * FROM t WHERE name LIKE '陈%' AND age = 10` , INDEX(name, age) 情况来说
在 MySQL5.6 之前没有引入索引下推优化时, 执行流程如下图, 在定位完 name 字段的索引后, 需要一条条进行回表查询, 然后再判断其他字段是否满足条件.
而 MySQL5.6 引入了索引下推优化后, 可以在所有遍历过程中, **对索引中包含的字段先进行判断过滤**, 然后再进行后续操作, 减少了回表次数.

## 建立索引的原则

-   建立索引的字段最好为 NOT NULL
-   索引字段占用空间越小越好
-   最左匹配原则
-   =和 in 建立索引时顺序可以任意, 比如 a = 1 and b = 2 and c = 3 建立(a, b, c)和(b, a, c)索引效果是一样的, MySQL 查询优化器会进行优化
-   建立的索引让索引的选择性尽可能接近 1, 唯一索引的索引选择性为 1
-   尽量扩展索引, 不要让索引冗余, 如有 SQL 需要对单个 a 进行索引, 那么上述条件建立的索引应该为(a, b, c)或(a, c, b)
-   索引列不能参与计算

## 什么情况下索引失效?

-   使用 != 或  <>
-   类型不一致导致索引失效
-   函数导致的索引失效, 函数用在索引列时, 不走索引
    如 `SELECT * FROM t WHERE DATE(create_time) = 'yyyy-MM-dd'`
-   运算符导致的索引失效

    如 `SELECT * FROM t WHERE k - 1 = 2`, 若有 INDEX(k), 则不走索引

-   OR 引起的索引失效

    如 `SELECT * FROM t WHERE k = 1 OR j = 2`, 若有 INDEX(k), 则不走索引, 如果 OR 连接的时同一个字段, 则不会失效

-   模糊查询导致的索引失效

    如 `SELECT * FROM t WHERE name = '%三'`, %放字符串字段前匹配不走索引

-   NOT IN, NOT EXISTS 导致索引失效

## 索引数据结构方案对比

### BST 和 AVL 等二叉树模型

BST 不管是查询还是更新, 都只需要 OLog(n) 的时间复杂度. 但是 BST 在某种情况下, 会使得其退化成链表. 如果想让他保持平衡, 那么就可以使用 AVL. 对于二叉树来说, 如果数据量十分大, 那么这个层数就会越堆越高, 而数据是存放在磁盘中, 那么意味着要访问非常多的数据块, 就非常影响性能。

### B 树模型

B 树是多路搜索树, B 树每个结点都存储着数据, 解决了二叉树随数据变大而层数变高导致对磁盘 IO 时的性能低下问题.

但是很明显, B 树还不是最理想的存储结构, 试想一下如果进行范围查询, 对于范围中的数据来说, 那么不是每次都要从根节点开始往下找么, 必然有性能的问题.

### B+树

于是在基于 B 树的模型上, 出现了 B+树,
B+树只有叶子节点是存储数据的, 而其他非叶子节点均为索引, 叶子节点用链表串起来, 且保证了有序. 在范围查询就只需找到其中一个数据, 之后向后遍历即可.
