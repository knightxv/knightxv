---
title: 事务
date: 2020-02-02 20:14:23
permalink: /pages/50e1ea/
categories:
  - 中间件
  - Mysql
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
# 事务

## 什么是数据库事务？

**事务**：一组逻辑操作单元，使数据从一种状态变换到另一种状态。
**事务处理的原则**：保证所有事务都作为 一个工作单元 来执行，即使出现了故障，都不能改变这种执行方式。

当在一个事务中执行多个操作时，要么所有的事务都被提交( commit )，那么这些修改就 永久 地保存下来；要么数据库管理系统将 放弃 所作的所有 修改 ，整个事务回滚( rollback )到最初状态。

事务最经典也经常被拿出来说例子就是转账了:

假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。

## 事务的实现原理

事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。

每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。

## 事务的特性 ACID

-   **原子性**：原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。
-   **一致性**：根据定义，一致性是指事务执行前后，数据从一个 合法性状态 变换到另外一个 合法性状态 。这种状态是 语义上 的而不是语法上的，跟具体的业务有关。

    那什么是合法的数据状态呢？满足 预定的约束 的状态就叫做合法的状态。通俗一点，这状态是由你自己来定义的（比如满足现实世界中的约束）。满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的！如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作之前的状态。

-   **隔离性**：事务的隔离性是指一个事务的执行 不能被其他事务干扰 ，即一个事务内部的操作及使用的数据对 并发 的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。
-   **持久性：**持久性是指一个事务一旦被提交，它对数据库中数据的改变就是 永久性的 ，接下来的其他操作和数据库故障不应该对其有任何影响。

    持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执行，从而使事务具有持久性。

## [事务 ACID 怎么实现的](https://www.cnblogs.com/rjzheng/p/10841031.html)

mysql 具有**redo log** 和**undo log**，这二种文件都是事务相关的问题。
每次开启一个事务，则 mysql 的 innodb 引擎就会生成一张**undo log**文件，该文件主要记录这个事务 ID 所产生的一些更新、删除、插入操作。

当事务 1 执行 update 的时候，就会将 udpate 记录到 undo log 文件，当事务进行 commit 的时候，就会将 undo log 文件删除，如果回滚时，则会根据 undo log 文件的内容进行执行插入回滚 SQL 脚本。

**redo log** 文件是数据库的一个共享的文件，也是一份写缓存的文件，试想一下，每次操作读写都需要去访问磁盘的随机 IO，其实会很耗时，因此可以将一些频繁的页内容加载到内存的一个缓存 buffer 中，当进行读操作时去查看缓存 buffer 是否有对应的数据，如果没有，则去磁盘查询，查询后再将查询的结果写入到缓存 buffer。当执行写操作的时候，就先去更新缓存 buffer,等到一定时间，将缓存 buffer 的数据再一次写入到磁盘中。但是这样就会有一个数据一致性的问题了，假设 buffer 的数据没有 flush 到磁盘，mysql 服务器就宕机了，那内存的 buffer 的数据也会清空，redo log 就解决了数据一致性的问题。

写操作的时候，不会写入到缓存 buffer 中，而是写入到 redo log 中，当事务提交后，redo log 的内容就 flush 到磁盘中，redo log 是一个文件，当服务器宕机了，也不影响 redo log 已保存后的数据，当 mysql 进行宕机后，redo log 还是有内容的，如果想事务提交，则就执行 redo log 的数据到磁盘，一般而言是会将 redo log 的数据进行回滚，也就是删除数据。

#### 原子性

利用 Innodb 的 undo log。
undo log 名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的 sql 语句，他需要记录你要回滚的相应日志信息。
例如

-   当你 delete 一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert 这条旧数据
-   当你 update 一条数据的时候，就需要记录之前的旧值，回滚的时候，根据旧值执行 update 操作
-   当年 insert 一条数据的时候，就需要这条记录的主键，回滚的时候，根据主键执行 delete 操作

undo log 记录了这些回滚需要的信息，当事务执行失败或调用了 rollback，导致事务需要回滚，便可以利用 undo log 中的信息将数据回滚到修改之前的样子。

#### 持久性

redo log 保证了持久性，事务提交了，redo log 的内容就会 flush 到磁盘中。
是利用 Innodb 的 redo log。

正如之前说的，Mysql 是先把磁盘上的数据加载到内存中，在内存中对数据进行修改，再刷回磁盘上。如果此时突然宕机，内存中的数据就会丢失。

怎么解决这个问题？

简单啊，事务提交前直接把数据写入磁盘就行啊。

这么做有什么问题？

-   只修改一个页面里的一个字节，就要将整个页面刷入磁盘，太浪费资源了。毕竟一个页面 16kb 大小，你只改其中一点点东西，就要将 16kb 的内容刷入磁盘，听着也不合理。

-   毕竟一个事务里的 SQL 可能牵涉到多个数据页的修改，而这些数据页可能不是相邻的，也就是属于随机 IO。显然操作随机 IO，速度会比较慢。

于是，决定采用 redo log 解决上面的问题。当做数据修改的时候，不仅在内存中操作，还会在 redo log 中记录这次操作。当事务提交的时候，会将 redo log 日志进行刷盘(redo log 一部分在内存中，一部分在磁盘上)。当数据库宕机重启的时候，会将 redo log 中的内容恢复到数据库中，再根据 undo log 和 binlog 内容决定回滚数据还是提交数据。

采用 redo log 的好处?

其实好处就是将 redo log 进行刷盘比对数据页刷盘效率高，具体表现如下:

-   redo log 体积小，毕竟只记录了哪一页修改了啥，因此体积小，刷盘快。
-   redo log 是一直往末尾进行追加，属于顺序 IO。效率显然比随机 IO 来的快。

#### 隔离性

> mysql 采用 mvcc 进行，通过版本链、read view 以及隐藏的三个字段来实现.

详情文章参考： https://blog.csdn.net/SIESTA030/article/details/123113437

至于 MVCC,即多版本并发控制(Multi Version Concurrency Control),一个行记录数据有多个版本对快照数据，这些快照数据在 undo log 中。

如果一个事务读取的行正在做 DELELE 或者 UPDATE 操作，读取操作不会等行上的锁释放，而是读取该行的快照版本。

由于 MVCC 机制在可重复读(Repeateable Read)和读已提交(Read Commited)的 MVCC 表现形式不同，就不赘述了。

但是有一点说明一下，在事务隔离级别为读已提交(Read Commited)时，一个事务能够读到另一个事务已经提交的数据，是不满足隔离性的。但是当事务隔离级别为可重复读(Repeateable Read)中，是满足隔离性的。

## 并发事务带来的问题

-   **脏读 Dirty Read**
    当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的
-   **丢失修改 Lost to modify**
    指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改
-   **不可重复读 Unrepeatable Read**
    指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读. 侧重点为修改.
-   **幻读 Phantom Read**
    幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读. 侧重点为新增或删除.

## 隔离性与隔离级别

-   **串行化 Serializable**
    -   最高隔离级别. 强制事务串行执行. 避免幻读问题. SERIALIZABLE 会在读取的每一行数据上都加锁, 所以可能导致大量的超时和锁竞争问题。
    -   可避免脏读、不可重复读、幻读。
-   **可重复读 Repeatable Read** (MySQL 默认隔离级别)
    -   保证了在同一个事务中多次读取同样的记录的结果是一致的. 可能会发生幻读. InnoDB 通过 MVCC 多并发版本控制来解决幻读问题.
    -   可避免脏读、不可重复读的发生。
-   **读提交 Read Committed**
    -   一个事务从开始直到提交之前, 所做的任何修改都是对其他事务不可见的. 可能会发生幻读, 不可重复读.
    -   可避免脏读的发生。
-   **读未提交 Read Uncommitted**
    -   在这个级别下, 事务中的修改, 即使没有提交, 对其他事务也是可见的. 可能会导致脏读, 不可重复读或幻读.
    -   最低级别，任何情况都无法保证。

在 MySQL 数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在 Oracle 数据库中，只支持 Serializable (串行化)级别和 Read committed (读已提交)这两种级别，其中默认的为 Read committed 级别。

#### 隔离性

| 隔离级别 | 说明                                                                                                                            |
| -------- | ------------------------------------------------------------------------------------------------------------------------------- |
| 读未提交 | 一个事务还没提交时，它做的变更就能被别的事务看到                                                                                |
| 读提交   | 一个事务提交之后，它做的变更才会被其他事务看到                                                                                  |
| 可重复读 | 一个事务中，对同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。**InnoDB 默认级别**。 |
| 串行化   | 事务串行化执行，每次读都需要获得表级共享锁，读写相互都会阻塞，隔离级别最高，牺牲系统并发性。                                    |

不同的隔离级别是为了解决不同的问题。也就是脏读、幻读、不可重复读。

| 隔离级别 | **脏读**   | **不可重复读** | **幻读**   |
| -------- | ---------- | -------------- | ---------- |
| 读未提交 | 可以出现   | 可以出现       | 可以出现   |
| 读提交   | 不允许出现 | 可以出现       | 可以出现   |
| 可重复读 | 不允许出现 | 不允许出现     | 可以出现   |
| 串行化   | 不允许出现 | 不允许出现     | 不允许出现 |

那么不同的隔离级别，隔离性是如何实现的，为什么不同事物间能够互不干扰？ 答案是 **锁 和 MVCC。**

## 什么是脏读？幻读？不可重复读？

1. 脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据

2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。

3. 幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

不可重复读侧重于修改，幻读侧重于新增或删除（多了或少量行），脏读是一个事务回滚影响另外一个事务。

## 事务的实现原理

事务是基于重做日志文件(redo log)和回滚日志(undo log)实现的。

每提交一个事务必须先将该事务的所有日志写入到重做日志文件进行持久化，数据库就可以通过重做日志来保证事务的原子性和持久性。

每当有修改事务时，还会产生 undo log，如果需要回滚，则根据 undo log 的反向语句进行逻辑操作，比如 insert 一条记录就 delete 一条记录。undo log 主要实现数据库的一致性。
