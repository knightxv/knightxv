---
title: Redis过期缓存策略
date: 2023-01-15 22:32:31
permalink: /pages/62b7f8/
categories:
  - 中间件
  - Redis
tags:
  - 
author: 
  name: knightxv
  link: https://github.com/knightxv
---
## [#](redis的缓存过期淘汰策略) Redis 的缓存过期淘汰策略

## [#](#_1、redis内存满了怎么办) 1、Redis 内存满了怎么办

### [#](#_1、redis默认内存多少-在哪里查看-如何设置修改) 1、redis 默认内存多少？在哪里查看?如何设置修改?

#### [#](#_1、查看redis最大占用内存) 1、查看 Redis 最大占用内存

![在这里插入图片描述](https://img-blog.csdnimg.cn/eafe1b82cc0a4185a5a6c0ede6c81f4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhb3h1ZUB4dWUuY29t,size_20,color_FFFFFF,t_70,g_se,x_16)

**打开 redis 配置文件，设置 maxmemory 参数，maxmemory 是 bytes 字节类型，注意转换。**

#### [#](#_2、redis默认内存多少可以用) 2、redis 默认内存多少可以用？

![在这里插入图片描述](https://img-blog.csdnimg.cn/16dc825e851f439ab6a524542e04b38b.png)

#### [#](#_3、一般生产上你如何配置) 3、一般生产上你如何配置？

一般推荐 Redis 设置内存为最大物理内存的四分之三

#### [#](#_4、如何修改redis内存设置) 4、如何修改 redis 内存设置

-   通过修改文件配置

![在这里插入图片描述](https://img-blog.csdnimg.cn/7987224b03ea49aca4e550a075430103.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeGlhb3h1ZUB4dWUuY29t,size_20,color_FFFFFF,t_70,g_se,x_16)

-   通过命令修改

![在这里插入图片描述](https://img-blog.csdnimg.cn/9fd8897a948c4048a81f1d1afc51cd42.png)

#### [#](#_5、什么命令查看redis内存使用情况) 5、什么命令查看 redis 内存使用情况?

### [#](#_2、结论) 2、结论

> 设置了 maxmemory 的选项，假如 redis 内存使用达到上限
>
> 没有加上过期时间就会导致数据写满 maxmemory 为了避免类似情况，使用内存淘汰策略

## [#](#_2、往redis里写的数据是怎么没了的-它如何删除的) 2、往 redis 里写的数据是怎么没了的?它如何删除的？

### [#](#_1、三种不同的删除策略) 1、三种不同的删除策略

> 如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？？
>
> NO

#### [#](#_1、立即删除) 1、立即删除

> Redis 不可能时时刻刻遍历所有被设置了生存时间的 key，来检测数据是否已经到达过期时间，然后对它进行删除。
>
> 立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对 cpu 是最不友好的。因为删除操作会占用 cpu 的时间，如果刚好碰上了 cpu 很忙的时候，比如正在做交集或排序等计算的时候，就会给 cpu 造成额外的压力，让 CPU 心累，时时需要删除，忙死。。。。。。。这会产生大量的性能消耗，同时也会影响数据的读取操作。
>
> 总结：对 CPU 不友好，用处理器性能换取存储空间 （拿时间换空间）

#### [#](#_2、惰性删除) 2、惰性删除

> 数据到达过期时间，不做处理。等下次访问该数据时，
>
> 如果未过期，返回数据 ；
>
> 发现已过期，删除，返回不存在。
>
> 惰性删除策略的缺点是，它对内存是最不友好的
>
> 如果一个键已经过期，而这个键又仍然保留在 redis 中，那么只要这个过期键不被删除，它所占用的内存就不会释放。
>
> 在使用惰性删除策略时，如果数据库中有非常多的过期键，而这些过期键又恰好没有被访问到的话，那么它们也许永远也不会被删除(除非用户手动执行 FLUSHDB)，我们甚至可以将这种情况看作是一种内存泄漏–无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的 Redis 服务器来说,肯定不是一个好消息
>
> 总结：对 memory 不友好，用存储空间换取处理器性能（拿空间换时间）

#### [#](#_3、定期删除) 3、定期删除

> 定期删除策略是前两种策略的折中：
>
> 定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。
>
> 周期性轮询 redis 库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度
>
> 特点 1：CPU 性能占用设置有峰值，检测频度可自定义设置
>
> 特点 2：内存压力不是很大，长期占用内存的冷数据会被持续清理
>
> 总结：周期性抽查存储空间 （随机抽查，重点抽查）
>
> redis 默认每个 100ms 检查，是否有过期的 key，有过期 key 则删除。注意：redis 不是每隔 100ms 将所有的 key 检查一次而是随机抽取进行检查(如果每隔 100ms,全部 key 进行检查，redis 直接进去 ICU)。因此，如果只采用定期删除策略，会导致很多 key 到时间没有删除。
>
> 定期删除策略的难点是确定删除操作执行的时长和频率：如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成立即删除策略，以至于将 CPU 时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的执行时长和执行频率。
>
> 总结：定期抽样 key，判断是否过期 会有漏网之鱼

1 定期删除时，从来没有被抽查到

2 惰性删除时，也从来没有被点中使用过

上述 2 步骤======> 大量过期的 key 堆积在内存中，导致 redis 内存空间紧张或者很快耗尽

## [#](#_3、redis缓存淘汰策略) 3、redis 缓存淘汰策略

### [#](#_1、noeviction-不会驱逐任何key) 1、noeviction: 不会驱逐任何 key

### [#](#_2、allkeys-lru-对所有key使用lru算法进行删除) 2、allkeys-lru: 对所有 key 使用 LRU 算法进行删除

### [#](#_3、volatile-lru-对所有设置了过期时间的key使用lru算法进行删除) 3、volatile-lru: 对所有设置了过期时间的 key 使用 LRU 算法进行删除

### [#](#_4、allkeys-random-对所有key随机删除) 4、allkeys-random: 对所有 key 随机删除

### [#](#_5、volatile-random-对所有设置了过期时间的key随机删除) 5、volatile-random: 对所有设置了过期时间的 key 随机删除

### [#](#_6、volatile-ttl-删除马上要过期的key) 6、volatile-ttl: 删除马上要过期的 key

### [#](#_7、allkeys-lfu-对所有key使用lfu算法进行删除) 7、allkeys-lfu: 对所有 key 使用 LFU 算法进行删除

### [#](#_8、volatile-lfu-对所有设置了过期时间的key使用lfu算法进行删除) 8、volatile-lfu: 对所有设置了过期时间的 key 使用 LFU 算法进行删除

### [#](#_9、总结) 9、总结

-   2 \* 4 得 8
-   2 个维度
-   -   过期键中筛选
-   所有键中筛选
-   4 个方面
-   -   LRU
-   LFU
-   random
-   ttl

### [#](#_10、生产用哪个) 10、生产用哪个
