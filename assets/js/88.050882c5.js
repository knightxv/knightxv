(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{412:function(t,v,_){"use strict";_.r(v);var s=_(4),a=Object(s.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"系统调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统调用"}},[t._v("#")]),t._v(" 系统调用")]),t._v(" "),v("p",[t._v("介绍系统调用之前，我们先来了解一下用户态和系统态。")]),t._v(" "),v("h2",{attrs:{id:"什么是用户态和内核态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是用户态和内核态"}},[t._v("#")]),t._v(" 什么是用户态和内核态？")]),t._v(" "),v("p",[t._v("用户态和系统态是操作系统的两种运行状态：")]),t._v(" "),v("h3",{attrs:{id:"内核态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内核态"}},[t._v("#")]),t._v(" 内核态：")]),t._v(" "),v("p",[t._v("内核态运行的程序可以访问计算机的任何数据和资源，不受限制，包括外围设备，比如网卡、硬盘等。处于内核态的 CPU 可以从一个程序切换到另外一个程序，并且占用 CPU 不会发生抢占情况。")]),t._v(" "),v("h3",{attrs:{id:"用户态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态"}},[t._v("#")]),t._v(" 用户态：")]),t._v(" "),v("p",[t._v("用户态运行的程序只能受限地访问内存，只能直接读取用户程序的数据，并且不允许访问外围设备，用户态下的 CPU 不允许独占，也就是说 CPU 能够被其他程序获取。")]),t._v(" "),v("p",[t._v("将操作系统的运行状态分为用户态和内核态，主要是为了对访问能力进行限制，防止随意进行一些比较危险的操作导致系统的崩溃，比如设置时钟、内存清理，这些都需要在内核态下完成 。")]),t._v(" "),v("h3",{attrs:{id:"用户态和内核态是如何切换的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用户态和内核态是如何切换的"}},[t._v("#")]),t._v(" 用户态和内核态是如何切换的?")]),t._v(" "),v("p",[t._v("所有的用户进程都是运行在用户态的，但是我们上面也说了，用户程序的访问能力有限，一些比较重要的比如从硬盘读取数据，从键盘获取数据的操作则是内核态才能做的事情，而这些数据却又对用户程序来说非常重要。所以就涉及到两种模式下的转换，即用户态 -> 内核态 -> 用户态，而唯一能够做这些操作的只有 系统调用，而能够执行系统调用的就只有 操作系统。")]),t._v(" "),v("p",[t._v("一般用户态 -> 内核态的转换我们都称之为 trap 进内核，也被称之为 陷阱指令(trap instruction)。")]),t._v(" "),v("p",[t._v("他们的工作流程如下：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/knightxv/image-hosting@master/20230202/xt-7.61s447vujm80.webp",alt:""}})]),t._v(" "),v("ul",[v("li",[v("p",[t._v("首先用户程序会调用 glibc 库，glibc 是一个标准库，同时也是一套核心库，库中定义了很多关键 API。")])]),t._v(" "),v("li",[v("p",[t._v("glibc 库知道针对不同体系结构调用系统调用的正确方法，它会根据体系结构应用程序的二进制接口设置用户进程传递的参数，来准备系统调用。")])]),t._v(" "),v("li",[v("p",[t._v("然后，glibc 库调用软件中断指令(SWI) ，这个指令通过更新 CPSR 寄存器将模式改为超级用户模式，然后跳转到地址 0x08 处。")])]),t._v(" "),v("li",[v("p",[t._v("到目前为止，整个过程仍处于用户态下，在执行 SWI 指令后，允许进程执行内核代码，MMU 现在允许内核虚拟内存访问")])]),t._v(" "),v("li",[v("p",[t._v("从地址 0x08 开始，进程执行加载并跳转到中断处理程序，这个程序就是 ARM 中的 vector_swi()。")])]),t._v(" "),v("li",[v("p",[t._v("在 vector_swi() 处，从 SWI 指令中提取系统调用号 SCNO，然后使用 SCNO 作为系统调用表 sys_call_table 的索引，调转到系统调用函数。")])]),t._v(" "),v("li",[v("p",[t._v("执行系统调用完成后，将还原用户模式寄存器，然后再以用户模式执行。")])])]),t._v(" "),v("h3",{attrs:{id:"中断的处理过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#中断的处理过程"}},[t._v("#")]),t._v(" 中断的处理过程?")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/knightxv/image-hosting@master/20230202/xt-8.2xqmuttlx220.webp",alt:""}})]),t._v(" "),v("h2",{attrs:{id:"什么是系统调用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是系统调用"}},[t._v("#")]),t._v(" 什么是系统调用")]),t._v(" "),v("p",[v("strong",[t._v("说了用户态和系统态之后，那么什么是系统调用呢？")])]),t._v(" "),v("p",[t._v("我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！")]),t._v(" "),v("p",[t._v("也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。")]),t._v(" "),v("p",[t._v("这些系统调用按功能大致可分为如下几类：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("设备管理")]),t._v(" ：完成设备的请求或释放，以及设备启动等功能。")]),t._v(" "),v("li",[v("strong",[t._v("文件管理")]),t._v(" ：完成文件的读、写、创建及删除等功能。")]),t._v(" "),v("li",[v("strong",[t._v("进程控制")]),t._v(" ：完成进程的创建、撤销、阻塞及唤醒等功能。")]),t._v(" "),v("li",[v("strong",[t._v("进程通信")]),t._v(" ：完成进程之间的消息传递或信号传递等功能。")]),t._v(" "),v("li",[v("strong",[t._v("内存管理")]),t._v(" ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。")])]),t._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/knightxv/image-hosting@master/20230202/xt-9.6flni9f8lug0.webp",alt:""}})])])}),[],!1,null,null,null);v.default=a.exports}}]);