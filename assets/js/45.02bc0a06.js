(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{368:function(t,a,v){"use strict";v.r(a);var _=v(4),r=Object(_.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁"}},[t._v("#")]),t._v(" 锁")]),t._v(" "),a("p",[t._v("根据加锁范围, MySQL 里的锁大致分成 "),a("strong",[t._v("全局锁")]),t._v(" 、"),a("strong",[t._v("表锁")]),t._v(" 和 "),a("strong",[t._v("行锁")])]),t._v(" "),a("h3",{attrs:{id:"全局锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[t._v("#")]),t._v(" 全局锁")]),t._v(" "),a("p",[t._v("全局锁就是对整个数据库实例加锁. MySQL 提供了一个加全局读锁的方法, "),a("code",[t._v("Flush tables with read lock(FTWRL)")]),t._v(" 使整个库都处于只读状态. 一般用于全局备份.")]),t._v(" "),a("h3",{attrs:{id:"表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[t._v("#")]),t._v(" 表锁")]),t._v(" "),a("p",[t._v("InnoDB 中的表锁十分鸡肋, 一般都是通过 "),a("code",[t._v("MySQL")]),t._v(" 的 server 层下的 "),a("strong",[t._v("元数据锁 (Metadata Lock)")]),t._v(" 来实现当对表执行 DDL 语句时, 使得其他事务阻塞. InnoDB 厉害之处是实现了更细粒度的行锁.")]),t._v(" "),a("h3",{attrs:{id:"行锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行锁"}},[t._v("#")]),t._v(" 行锁")]),t._v(" "),a("p",[a("strong",[t._v("在 InnoDB 事务中，行锁通过给索引上的索引项加锁来实现。这意味着只有通过索引条件检索数据，InnoDB 才使用行级锁，否则将使用表锁。")]),t._v("\n行级锁定同样分为两种类型："),a("strong",[t._v("共享锁")]),t._v("和"),a("strong",[t._v("排他锁")]),t._v("，以及加锁前需要先获得的意向共享锁和意向排他锁。")]),t._v(" "),a("ul",[a("li",[t._v("共享锁：读锁，允许其他事务再加 S 锁，不允许其他事务再加 X 锁，即其他事务只读不可写。select...lock in share mode 加锁。")]),t._v(" "),a("li",[t._v("排它锁：写锁，不允许其他事务再加 S 锁或者 X 锁。insert、update、delete、for update 加锁。")])]),t._v(" "),a("p",[a("strong",[t._v("行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。")])]),t._v(" "),a("h4",{attrs:{id:"行锁的实现算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行锁的实现算法"}},[t._v("#")]),t._v(" 行锁的实现算法")]),t._v(" "),a("ul",[a("li",[t._v("**Record Lock 记录锁：**单个行记录上的锁，总是会去锁住索引记录。\n仅仅只是把一条记录给锁上, 当一个事务获取了记录的 S 锁, 其他事务也能够获得 S 锁, 但无法获得 X 锁; 而一个事务获取了记录的 X 锁, 则其他事务不能获得 S 锁和 X 锁.")]),t._v(" "),a("li",[t._v("**Gap Lock 间隙锁 ** 解决幻读\n在 RR 级别下产生幻读问题一般有两种解决方案: MVCC 或加锁.\n假设有记录 id = [1, 3, 4], 这时有事务想在[1, 3]之间插入一个 id = 2 的记录, 可能产生幻读, 所以给 id = 3 的记录前的间隙加上了 Gap Lock, 意思是在释放这个 Gap Lock 之前都不允许其他事务在这条记录前插入数据. 那如果在最后一条后插入数据呢 ? 在表最后会有一条伪记录 Supremum, 对 Supremum 加 Gap Lock,   这样就会防止在最后插入记录造成的幻读.")]),t._v(" "),a("li",[a("strong",[t._v("Next-Key Lock")]),t._v("\n有时, 既想锁住某条记录, 又想阻止在记录前的间隙插入新记录. 于是就有了 Next-Key Lock. 本质就是一个 Record Lock + Gap Lock，左开又闭.")]),t._v(" "),a("li",[a("strong",[t._v("Insert Intention Lock 插入意向锁")]),t._v("\n若插入位置已被别的事务加了 Gap Lock, 则事务在等待时也需要在内存中生成一个锁结构, 被称为 插入意向锁. 当 Gap Lock 释放的时候,插入意向锁就会将等待事务中锁结构内的 is_waiting 的状态改为 false, 然后开始继续往下执行插入操作.")]),t._v(" "),a("li",[a("strong",[t._v("隐式锁")]),t._v("\n隐式锁其实是一种延迟生成锁结构的方案, 通过判断事务 id, 确定两个并发事务之间是否真的有必要加锁, 若需要, 则会生成锁结构, 然后进入等待; 不需要, 那么就没必要浪费内存去对事务生成锁结构, 降低维护成本. 类似于乐观锁实现.")])]),t._v(" "),a("h3",{attrs:{id:"锁之于隔离性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#锁之于隔离性"}},[t._v("#")]),t._v(" 锁之于隔离性")]),t._v(" "),a("p",[t._v("大致介绍了下锁，可以看到。有了锁，当某事务正在写数据时，其他事务获取不到写锁，就无法写数据，一定程度上保证了事务间的隔离")])])}),[],!1,null,null,null);a.default=r.exports}}]);