(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{430:function(_,v,a){"use strict";a.r(v);var t=a(4),s=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"im-系统架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#im-系统架构"}},[_._v("#")]),_._v(" IM 系统架构")]),_._v(" "),v("h2",{attrs:{id:"整体架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#整体架构"}},[_._v("#")]),_._v(" 整体架构")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/knightxv/image-hosting@master/20230118/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230118215118.3no2ng0ajne0.webp",alt:"IM系统架构图"}})]),_._v(" "),v("p",[_._v("服务端由接入层、逻辑层和存储层组成，好处在于各个层次能够依据业务特点专注于自己的事情，提高系统复用性，降低业务间的耦合。")]),_._v(" "),v("p",[_._v("（1）接入层：消息通过 websocket 协议接入，其他通过 http/https 协议接入，消息是高频及核心功能，通过双协议路由，体现了轻重分离的设计思想。")]),_._v(" "),v("p",[_._v("（2）逻辑层：通过 rpc 实现无状态逻辑服务，易于平行扩展，消息通过 MQ 解耦。")]),_._v(" "),v("p",[_._v("（3）存储层：")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[_._v("数据分层存储，充分利用不同存储组件的特性\n")])])]),v("ul",[v("li",[_._v("redis 存储 token 和 seq；")]),_._v(" "),v("li",[_._v("mongodb 存储离线消息，并定时删除")]),_._v(" "),v("li",[_._v("mysql 存储全量历史消息以及用户相关资料")])]),_._v(" "),v("p",[_._v("（4）Consul：服务注册和发现、以及分布式配置中心。")]),_._v(" "),v("h2",{attrs:{id:"路由-接入层-方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路由-接入层-方案"}},[_._v("#")]),_._v(" 路由（接入层）方案")]),_._v(" "),v("h3",{attrs:{id:"广播"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#广播"}},[_._v("#")]),_._v(" 广播")]),_._v(" "),v("ol",[v("li",[_._v("IM server 将消息扇出式的发送给所有接入层服务")]),_._v(" "),v("li",[_._v("接入层服务只会处理自己持有uid的连接，而忽略其他")])]),_._v(" "),v("h3",{attrs:{id:"一致性哈希"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一致性哈希"}},[_._v("#")]),_._v(" 一致性哈希")]),_._v(" "),v("ol",[v("li",[_._v("ipConf服务与IM Server使用同一种hash方式")]),_._v(" "),v("li",[_._v("按uid进行分片，IM Server直接计算出该用户连接在哪个服务器上")]),_._v(" "),v("li",[_._v("通过统一的服务注册发现系统")]),_._v(" "),v("li",[_._v("当水平扩展接入层服务时，利用虚拟节点特性迁移长链接")]),_._v(" "),v("li",[_._v("对于迁移的用户来说，通过断线重连的方法实现")])]),_._v(" "),v("h3",{attrs:{id:"路由服务层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#路由服务层"}},[_._v("#")]),_._v(" 路由服务层")]),_._v(" "),v("ol",[v("li",[_._v("构建一个服务，底层使用kv存储uid与接入机器之间的映射关系")]),_._v(" "),v("li",[_._v("同时可根据不同的会话类型组织映射关系，群组，多设备等kv关系")]),_._v(" "),v("li",[_._v("有接入层服务在线同步的方式更新kv")]),_._v(" "),v("li",[_._v("路由服务与IM Server之间维护消息队列，IM Server随意给到消息队")]),_._v(" "),v("li",[_._v("任意路由服务消费MQ解析此消息的路由信息确定接入层机器位置")]),_._v(" "),v("li",[_._v("根据接入层机器标识创建routeKey，将消息发送给此接入层机器专用队列")])]),_._v(" "),v("h2",{attrs:{id:"消息时序一致性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息时序一致性"}},[_._v("#")]),_._v(" 消息时序一致性")]),_._v(" "),v("ol",[v("li",[_._v("消息如何不丢失？")])]),_._v(" "),v("ul",[v("li",[_._v("上行消息客户端重试")]),_._v(" "),v("li",[_._v("下行消息服务端重试")]),_._v(" "),v("li",[_._v("接收消息方需要回复ACK，避免无限重试")])]),_._v(" "),v("ol",{attrs:{start:"2"}},[v("li",[_._v("如何防止重复？")])]),_._v(" "),v("ul",[v("li",[v("p",[_._v("上行消息")]),_._v(" "),v("ul",[v("li",[_._v("客户端在一个会话内生成一个消息的递增cid，服务器存储当前会话接收到的max cid")]),_._v(" "),v("li",[_._v("如果发送的消息不是max_cid+1，则将其丢弃")])])]),_._v(" "),v("li",[v("p",[_._v("下行消息")]),_._v(" "),v("ul",[v("li",[_._v("服务端为每个发送的消息分配seqid，客户的维护接收到的最大max_seq_id")]),_._v(" "),v("li",[_._v("如果发送的消息不是max_seq_id+1，则将其丢弃")])])])]),_._v(" "),v("ol",{attrs:{start:"3"}},[v("li",[_._v("如何保证消息是有序的？")])]),_._v(" "),v("ul",[v("li",[_._v("按某个递增的消息ID排序\n"),v("ul",[v("li",[_._v("上行消息按cid为每个消息分配seqID")]),_._v(" "),v("li",[_._v("下行消息客户端按seqID进行排序")])])])]),_._v(" "),v("h2",{attrs:{id:"如何生成递增的消息id"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何生成递增的消息id"}},[_._v("#")]),_._v(" 如何生成递增的消息ID？")]),_._v(" "),v("h3",{attrs:{id:"纯拉模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#纯拉模式"}},[_._v("#")]),_._v(" 纯拉模式")]),_._v(" "),v("p",[_._v("不存在一致性问题，只要保证上行消息一致性即可")]),_._v(" "),v("h3",{attrs:{id:"单调递增id生成器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单调递增id生成器"}},[_._v("#")]),_._v(" 单调递增ID生成器")]),_._v(" "),v("p",[_._v("保证会话内seqID的‘万有一失’的单调递增性+拉模式消息补洞")]),_._v(" "),v("h3",{attrs:{id:"双id链方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双id链方法"}},[_._v("#")]),_._v(" 双ID链方法")]),_._v(" "),v("ol",[v("li",[_._v("接收方为每个会话保留preID(上一次接收到消息的id)")]),_._v(" "),v("li",[_._v("发送方发送当前消息的id以及上一次发送消息的id(preID)")]),_._v(" "),v("li",[_._v("形成消息链条，接收方对比preID判断是否一致来识别是否存在消息漏洞")]),_._v(" "),v("li",[_._v("如果preID不匹配，则将接收方的preID返回")]),_._v(" "),v("li",[_._v("发送方回退到接收方的preID的位置，重置所有消息心跳后重新发送")])]),_._v(" "),v("h2",{attrs:{id:"推拉结合"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#推拉结合"}},[_._v("#")]),_._v(" 推拉结合:")]),_._v(" "),v("ol",[v("li",[_._v("下行消息给客户端发送拉取信令，通知客户端根据自身seqID拉取消息")]),_._v(" "),v("li",[_._v("pull 请求本身可作为上一次请求的ACK")])]),_._v(" "),v("p",[_._v("上行消息 PreID+下行消息 推拉结合")]),_._v(" "),v("h2",{attrs:{id:"消息架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息架构"}},[_._v("#")]),_._v(" 消息架构")]),_._v(" "),v("h3",{attrs:{id:"私聊"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#私聊"}},[_._v("#")]),_._v(" 私聊")]),_._v(" "),v("p",[_._v("消息模型采用经典的收件箱模型，并通过全局 seq 做消息对齐，这里带来架构的简化.")]),_._v(" "),v("p",[_._v("以下我们简单讲解消息如何发送，系统如何简单解耦，接收方如何实时收到消息，并如何利用 seq 做全局消息对齐，确保消息百分百可达。")]),_._v(" "),v("p",[_._v("（1）用户 A 发送消息，msg_gateway 进行消息拆分，并落地 MQ，MQ 根据 userId 写入不同的 partition 后返回给 A 成功，消息发送流程结束")]),_._v(" "),v("p",[_._v("（2）msg_transfer 通过 MQ 消费者监听消息达到，通过 redis 增加 userId 对应的 seq，并把 seq 和消息关联后写入 mongodb，离线消息存储，比如用户不在线或者推送失败时同步消息使用。写入成功后，再调用 pusher 推送，根据 B 所连接的 msg_gateway，进行消息推送（由于网络波动或者 B 不在线等原因，可能会推送失败）。")]),_._v(" "),v("p",[_._v("（3）客户端在任何有重连动作（包括重新登录、网络波动等）发生时，首先会获取自身在服务端最大的 seq，和本地 seq 做差值对比，把差值消息通过接口主动拉取到本地，这样完成了本地和服务端消息对齐。")]),_._v(" "),v("h3",{attrs:{id:"群聊"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#群聊"}},[_._v("#")]),_._v(" 群聊")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("当群的规模比较小（小于 500 人）的时候，采用私聊的方式进行推送。")]),_._v(" "),v("p",[_._v("用户 A 发送群聊消息，msg_gateway 获取群成员并扩散，把消息放入到群成员的收件箱中，按照私聊的方式进行同步（类似于用户 A 向每个成员发送私聊数据）。")])]),_._v(" "),v("li",[v("p",[_._v("当群规模比较大（大于 500 人），就不能按照写扩散的形式进行推送了。这时候就需要新建一个收件箱，用户主动到这个收件箱里面同步。")])])]),_._v(" "),v("h3",{attrs:{id:"读扩散问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读扩散问题"}},[_._v("#")]),_._v(" 读扩散问题")]),_._v(" "),v("p",[_._v("当用户加的大群（大于 500 人）比较多，每个会话的 Timeline 中保存了这个会话的全量消息。接收端需要对每个会话都拉取一次才能获取全部消息，读被大大的放大，并且会产生很多无效的读，因为并不是每个会话都会有新消息产生。")]),_._v(" "),v("p",[_._v("解决方案：")]),_._v(" "),v("blockquote",[v("p",[_._v("整体采用推拉结合模式：有新消息时服务器会先推一个有新消息的通知给前端，前端接收到通知后就向服务器拉取消息。")])]),_._v(" "),v("p",[_._v("具体流程如下：\n（1）当用户登录的时候，客户端发送要监听的群 ID 以及所对应的本地 req 进行初始化，服务端查询对应的最新 req，对比出差值，把差值推送给客户端。客户端主动同步。\n（2）初始化完成后，会通过 MQ 的订阅发布模式，监听群的消息变更，当监听到群有"),v("code",[_._v("有新消息的通知")]),_._v("时，通过 msg_gateway 通知给用户。")])])}),[],!1,null,null,null);v.default=s.exports}}]);