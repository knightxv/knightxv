(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{399:function(t,e,a){"use strict";a.r(e);var s=a(4),r=Object(s.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"tcp-四次挥手过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手过程"}},[t._v("#")]),t._v(" TCP 四次挥手过程")]),t._v(" "),e("h2",{attrs:{id:"状态变化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#状态变化"}},[t._v("#")]),t._v(" 状态变化")]),t._v(" "),e("p",[t._v("Client 状态变化：Fin-Wait-1 -> Fin-Wait-2 -> Time-Wait -> Closed")]),t._v(" "),e("p",[t._v("Server 状态变化：Close-Wait -> Last-Ack -> Closed")]),t._v(" "),e("h2",{attrs:{id:"具体流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#具体流程"}},[t._v("#")]),t._v(" 具体流程")]),t._v(" "),e("p",[t._v("第一次挥手：客户端发送连接释放报文 FIN=1，序号(握手时初始序号 + 发送的字节数据数量 + 1)seq=u，发送完毕后，客户端进入 FIN_WAIT_1 状态。")]),t._v(" "),e("p",[t._v("第二次挥手：服务器发出确认收到报文 ACK=1，确认号 ack=u+1，序列号(握手时初始序号 + 回复的字节数据)seq=v，发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态。")]),t._v(" "),e("p",[t._v("第三次挥手：关闭连接，发送连接释放报文 FIN=1，确认号 ack=u+1，初始序号 seq=w，发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。")]),t._v(" "),e("p",[t._v("第四次挥手： 客户端接收到来自服务器端的关闭请求，发回确认收到报文 ACK=1，确认序号 seq=w+1，初始序号 ack=u+1，客户端进入 TIME_WAIT 状态，等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://jsd.cdn.zzko.cn/gh/knightxv/image-hosting@master/20230128/4.5uyqppqe38k0.webp",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"tcp-四次挥手过程中-为什么需要等待-2msl-才进入-closed-关闭状态"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手过程中-为什么需要等待-2msl-才进入-closed-关闭状态"}},[t._v("#")]),t._v(" TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态?")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。 这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的服务端就收不到对已发送的 FIN + ACK 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 CLOSED 状态。（简述：防止 ack 报文丢失，Server 再次发送 Fin 报文，一来一回最长时间就是 2MSL）")])]),t._v(" "),e("li",[e("p",[t._v("防止已失效的连接请求报文段出现在本连接中。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。")])])]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结：")]),t._v(" "),e("p",[t._v("Server 端可能还有数据没有发送完毕。Client 发出连接释放通知，Server 确认收到后，Client 就进入半关闭状态（只收消息不发消息），Server 把未发完的数据发送完毕后，发送连接释放通知，Client 确认后就关闭连接。")])])}),[],!1,null,null,null);e.default=r.exports}}]);