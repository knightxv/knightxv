(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{353:function(t,a,s){"use strict";s.r(a);var r=s(4),e=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"底层数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#底层数据结构"}},[t._v("#")]),t._v(" 底层数据结构")]),t._v(" "),a("h2",{attrs:{id:"跳跃表-跳表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跳跃表-跳表"}},[t._v("#")]),t._v(" "),a("a",{attrs:{href:"%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%88%E8%B7%B3%E8%A1%A8%EF%BC%89"}},[t._v("#")]),t._v("跳跃表（跳表）")]),t._v(" "),a("h3",{attrs:{id:"简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简介"}},[t._v("#")]),t._v(" 简介")]),t._v(" "),a("p",[t._v("​ 有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis 采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。")]),t._v(" "),a("h2",{attrs:{id:"有序链表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有序链表"}},[t._v("#")]),t._v(" 有序链表")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/3a9ae628e2df4089a7ddf9ec1c240960.png",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("​ 要查找值为 51 的元素，需要从第一个元素开始依次查找、比较才能找到。共需要 6 次比较。")]),t._v(" "),a("h2",{attrs:{id:"跳表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#跳表"}},[t._v("#")]),t._v(" 跳表")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/dad9458de7534ec7bb575db710da2dfb.png",alt:"在这里插入图片描述"}})]),t._v(" "),a("p",[t._v("从第 2 层开始，1 节点比 51 节点小，向后比较。")]),t._v(" "),a("p",[t._v("21 节点比 51 节点小，继续向后比较，后面就是 NULL 了，所以从 21 节点向下到第 1 层")]),t._v(" "),a("p",[t._v("在第 1 层，41 节点比 51 节点小，继续向后，61 节点比 51 节点大，所以从 41 向下")]),t._v(" "),a("p",[t._v("在第 0 层，51 节点为要查找的节点，节点被找到，共查找 4 次。")])])}),[],!1,null,null,null);a.default=e.exports}}]);