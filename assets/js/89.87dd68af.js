(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{411:function(t,v,_){"use strict";_.r(v);var a=_(4),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"内存管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内存管理"}},[t._v("#")]),t._v(" 内存管理")]),t._v(" "),v("h2",{attrs:{id:"地址分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#地址分类"}},[t._v("#")]),t._v(" 地址分类")]),t._v(" "),v("h3",{attrs:{id:"物理地址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#物理地址"}},[t._v("#")]),t._v(" 物理地址")]),t._v(" "),v("p",[t._v("物理地址就是内存中真正的地址，它就相当于是你家的门牌号，你家就肯定有这个门牌号，具有唯一性。"),v("strong",[t._v("不管哪种地址，最终都会映射为物理地址")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"虚拟内存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存"}},[t._v("#")]),t._v(" 虚拟内存")]),t._v(" "),v("p",[t._v("虚拟内存就是说，让"),v("strong",[t._v("物理内存扩充成更大的逻辑内存")]),t._v("，从而让程序获得更多的可用内存。程序不需要全部装入即可运行，运行时根据需要动态调入数据，若内存不够，还需要换出一些数据。")]),t._v(" "),v("p",[t._v("基于局部性原理，在"),v("strong",[t._v("程序装入")]),t._v("时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存，就可以让程序开始执行。")]),t._v(" "),v("p",[t._v("在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是虚拟内存。")]),t._v(" "),v("h2",{attrs:{id:"页表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#页表"}},[t._v("#")]),t._v(" 页表")]),t._v(" "),v("p",[v("strong",[t._v("为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张页表。")])]),t._v(" "),v("p",[t._v("把内存空间划分为"),v("strong",[t._v("大小相等且固定的块")]),t._v("，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，"),v("strong",[t._v("因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。")])]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("一个进程对应一张页表")])]),t._v(" "),v("li",[v("strong",[t._v("进程的每一页对应一个页表项")])]),t._v(" "),v("li",[v("strong",[t._v("每个**"),v("strong",[t._v("页表项*")]),t._v("*由“页号”和“块号”组成")])]),t._v(" "),v("li",[t._v("**页表****记录进程页面和实际存放的内存块之间的对应关系.**")]),t._v(" "),v("li",[v("strong",[t._v("每个页表项的长度是相同的，页号是“隐含”的")])])]),t._v(" "),v("p",[t._v("在 32 位系统中，一个进程对应一个页目录，一个页面可以寻址 1024 个页表，一个页表可以寻址 1024 个 4k 大小的物理 page，因此一个线性地址寻址 4G 的虚拟内存。")]),t._v(" "),v("h3",{attrs:{id:"线性地址寻址物理地址"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线性地址寻址物理地址"}},[t._v("#")]),t._v(" 线性地址寻址物理地址")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("一个 4 字节的指针对应着 32bit 大小，前 10 个 bit 位标识页目录中的偏移量，该偏移量对应的地址，保存的是页表的地址")])]),t._v(" "),v("li",[v("p",[t._v("得到页表地址，根据页表偏移（10~20bit 位标识），再得到页表项地址，那么我们就可以看到对应的是哪个物理页面")])]),t._v(" "),v("li",[v("p",[t._v("最后，根据物理页面的编号，访问物理页面，加上页内的偏移（20~32bit 位标识），就可以找到对应的数据或者指令。")])])]),t._v(" "),v("h2",{attrs:{id:"为什么虚拟地址空间切换会比较耗时"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么虚拟地址空间切换会比较耗时"}},[t._v("#")]),t._v(" 为什么虚拟地址空间切换会比较耗时？")]),t._v(" "),v("p",[t._v("进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 Cache 来缓存常用的地址映射，这样可以加速页表查找，这个 Cache 就是 TLB（translation Lookaside Buffer，TLB 本质上就是一个 Cache，是用来加速页表查找的）。")]),t._v(" "),v("h2",{attrs:{id:"什么是交换空间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是交换空间"}},[t._v("#")]),t._v(" 什么是交换空间？")]),t._v(" "),v("p",[t._v("操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为"),v("strong",[t._v("页(page)")]),t._v("。当内存资源不足时，"),v("strong",[t._v("Linux 把某些页的内容转移至硬盘上的一块空间上，以释放内存空间")]),t._v("。硬盘上的那块空间叫做"),v("strong",[t._v("交换空间")]),t._v("(swap space),而这一过程被称为交换(swapping)。"),v("strong",[t._v("物理内存和交换空间的总容量就是虚拟内存的可用容量。")])]),t._v(" "),v("p",[t._v("用途：")]),t._v(" "),v("ul",[v("li",[t._v("物理内存不足时一些不常用的页可以被交换出去，腾给系统。")]),t._v(" "),v("li",[t._v("程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);